# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
c-----------------------------------------------------------------------
c     
c  To do:
c     
c  1)  Why does hsmg_schwarz_toext2d not zero out a, whereas 3d does??  
c  2)  Convert all nelv refs to nelfld(ifield) or (nelmg?)  DONE
c  3)  Define mg_schwarz_wt for up to and including mg_h1_lmax   DONE
c  4)  MAKE CERTAIN common /hsmgw/ is LARGE enough in hsmg_tnsr and  DON
c      elsewhere!
c  5)  Devise and implement UNIT tests, now, so that you can test
c      pieces of the setup code in stages.
c  6)  Start developing and testing, in a linear fashion, the SETUP driv
c  7)  Make certain dssum flags declared for all levels  DONE
c  8)  Need TWO masks for each level:  one for A*x, and one for Schwarz!
c      NO -- one is fine.
c  9)  Modify axml so addition comes after dssum.  DONE
c     
c-----------------------------------------------------------------------
c     
c Some relevant parameters
c     
c param(41):
c     0 - use additive SEMG
c     1 - use hybrid SEMG (not yet working... but coming soon!)
c     
c param(42):   navier0.f, fasts.f
c     0 - use GMRES for iterative solver, use non-symmetric weighting
c     1 - use PCG for iterative solver, do not use weighting
c     
c param(43):   uzawa_gmres.f, navier6.f
c     0 - use additive multilevel scheme (requires param(42).eq.0)
c     1 - use original 2 level scheme
c     
c param(44):   fast3d.f, navier6.f
c     0 - base top-level additive Schwarz on restrictions of E
c     1 - base top-level additive Schwarz on restrictions of A
c     
c----------------------------------------------------------------------
      subroutine hsmg_setup()

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 41 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 41 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 42 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 42 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 43 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 43 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 44 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 44 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SEMHAT" 1
# 1
      parameter (lr2=2*lx1*lx1)
      common /ahat/ ah (lr2),bh (lr2),ch (lr2),dh (lr2)
     $             ,dph(lr2),jph(lr2),zh (lr2),wh (lr2)  ! Pressure GLL
     $             ,bgl(lr2),zgl(lr2),dgl(lr2),jgl(lr2)  ! Pressure GL 
      real ah,bh,ch,dh,dph,jph,zh,wh,bgl,zgl,dgl,jgl
c     
      parameter (l3=lx1*(lx1+1)*(lx1+2)/3)
      parameter (l2=lx1*(lx1+1)/2)
      common /hata/ dd(l3),zp(l2),ww(l2)   ! Aggregate arrays
# 45 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 45 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 46 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 46 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer nf,nc,nr
      integer nx,ny,nz
      
      mg_fld = 1
      if (ifield.gt.1) mg_fld = 2
      if (ifield.eq.1) call hsmg_index_0 ! initialize index sets
      
      call hsmg_setup_mg_nx  ! set nx values for each level of multigrid
      call hsmg_setup_semhat ! set spectral element hat matrices
      call hsmg_setup_intp
      
      call hsmg_setup_dssum  ! set direct stiffness summation handles
      call hsmg_setup_wtmask ! set restriction weight matrices and bc ma
      call hsmg_setup_fdm    ! set up fast diagonalization method
      call hsmg_setup_schwarz_wt(.false.)
      call hsmg_setup_solve  ! set up the solver
c     call hsmg_setup_dbg
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_semhat

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 70 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 70 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 71 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 71 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 72 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 72 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SEMHAT" 1
# 1
      parameter (lr2=2*lx1*lx1)
      common /ahat/ ah (lr2),bh (lr2),ch (lr2),dh (lr2)
     $             ,dph(lr2),jph(lr2),zh (lr2),wh (lr2)  ! Pressure GLL
     $             ,bgl(lr2),zgl(lr2),dgl(lr2),jgl(lr2)  ! Pressure GL 
      real ah,bh,ch,dh,dph,jph,zh,wh,bgl,zgl,dgl,jgl
c     
      parameter (l3=lx1*(lx1+1)*(lx1+2)/3)
      parameter (l2=lx1*(lx1+1)/2)
      common /hata/ dd(l3),zp(l2),ww(l2)   ! Aggregate arrays
# 73 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 73 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n,l
c     generate the SEM hat matrices for each level
c     top level
      n = mg_nx(mg_lmax)
      
      call semhat(ah,bh,ch,dh,zh,dph,jph,bgl,zgl,dgl,jgl,n,wh)
      call copy(mg_zh(1,mg_lmax),zgl,n-1) !top level based on gl points
      mg_nh(mg_lmax)=n-1
      mg_nhz(mg_lmax)=n-1
      if(.not.if3d) mg_nhz(mg_lmax)=1
c     lower levels
      do l=1,mg_lmax-1
         n = mg_nx(l)
         if(n.gt.1) then
            call semhat(ah,bh,ch,dh,zh,dph,jph,bgl,zgl,dgl,jgl,n,wh)
            call copy(mg_ah(1,l),ah,(n+1)*(n+1))
            call copy(mg_bh(1,l),bh,n+1)
            call copy(mg_dh(1,l),dh,(n+1)*(n+1))
            call transpose(mg_dht(1,l),n+1,dh,n+1)
            call copy(mg_zh(1,l),zh,n+1)
         else
            mg_zh(1,l) = -1.
            mg_zh(2,l) =  1.
         endif
         mg_nh(l)=n+1
         mg_nhz(l)=mg_nz(l)+1
      enddo
      
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_intp

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 105 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 105 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 106 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 106 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SEMHAT" 1
# 1
      parameter (lr2=2*lx1*lx1)
      common /ahat/ ah (lr2),bh (lr2),ch (lr2),dh (lr2)
     $             ,dph(lr2),jph(lr2),zh (lr2),wh (lr2)  ! Pressure GLL
     $             ,bgl(lr2),zgl(lr2),dgl(lr2),jgl(lr2)  ! Pressure GL 
      real ah,bh,ch,dh,dph,jph,zh,wh,bgl,zgl,dgl,jgl
c     
      parameter (l3=lx1*(lx1+1)*(lx1+2)/3)
      parameter (l2=lx1*(lx1+1)/2)
      common /hata/ dd(l3),zp(l2),ww(l2)   ! Aggregate arrays
# 107 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 107 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer l,nf,nc
      
      do l=1,mg_lmax-1
      
         nf=mg_nh(l+1)
         nc=mg_nh(l)
      
!        Standard multigrid coarse-to-fine interpolation
         call hsmg_setup_intpm(
     $           mg_jh(1,l),mg_zh(1,l+1),mg_zh(1,l),nf,nc)
         call transpose(mg_jht(1,l),nc,mg_jh(1,l),nf)
      
!        Fine-to-coarse interpolation for variable-coefficient operators
         call hsmg_setup_intpm(
     $           mg_jhfc(1,l),mg_zh(1,l),mg_zh(1,l+1),nc,nf)
         call transpose(mg_jhfct(1,l),nf,mg_jhfc(1,l),nc)
c        call outmat(mg_jhfc(1,l),nc,nf,'MG_JHFC',l)
      
      enddo
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_intpm(jh,zf,zc,nf,nc)
      integer nf,nc
      real jh(nf,nc),zf(1),zc(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 132 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 132 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real w(2*lx1+2)
      do i=1,nf
         call fd_weights_full(zf(i),zc,nc-1,1,w)
         do j=1,nc
            jh(i,j)=w(j)
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_dssum

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 144 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 144 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 145 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 145 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 146 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 146 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 147 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 147 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter (lxyz=(lx1+2)*(ly1+2)*(lz1+2))
      common /c_is1/ glo_num(lxyz*lelv)
      common /ivrtx/ vertex ((2**ldim)*lelt)
      
      integer*8 glo_num
      integer vertex
      integer nx,ny,nz
      integer l
      
c     set up direct stiffness summation for each level
      ncrnr = 2**ndim
      call get_vert
      
c++   write(6,*) mg_fld,' mgfld in hsmg_setup_dssum'
      do l=1,mg_lmax-1
         nx=mg_nh(l)
         ny=mg_nh(l)
         nz=mg_nhz(l)
         call setupds(mg_gsh_handle(l,mg_fld),nx,ny,nz
     $                ,nelv,nelgv,vertex,glo_num)
         nx=nx+2
         ny=ny+2
         nz=nz+2
         if(.not.if3d) nz=1
         call setupds(mg_gsh_schwarz_handle(l,mg_fld),nx,ny,nz
     $                ,nelv,nelgv,vertex,glo_num)
      enddo
      
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_wtmask

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 179 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 179 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 180 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 180 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer i,l
      i = mg_mask_index(mg_lmax,mg_fld-1)
      do l=1,mg_lmax
         mg_rstr_wt_index(l,mg_fld)=i
         mg_mask_index   (l,mg_fld)=i
         i=i+mg_nh(l)*mg_nhz(l)*2*ndim*nelv
         if(i .gt. lmgs*lmg_rwt*2*ldim*lelv) then
            itmp = i/(2*ldim*lelv)
            write(6,*) 'parameter lmg_rwt too small',i,itmp,lmg_rwt
            call exitt
         endif
         call hsmg_setup_rstr_wt(
     $           mg_rstr_wt(mg_rstr_wt_index(l,mg_fld))
     $          ,mg_nh(l),mg_nh(l),mg_nhz(l),l,mg_work)
         call hsmg_setup_mask(
     $           mg_mask(mg_mask_index(l,mg_fld))
     $          ,mg_nh(l),mg_nh(l),mg_nhz(l),l,mg_work)
      enddo
      mg_mask_index(l,mg_fld)=i
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_wtmask

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 203 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 203 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 204 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 204 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer i,l
      i = mg_mask_index(mg_lmax,mg_fld-1)
      do l=1,mg_lmax-1
         mg_rstr_wt_index(l,mg_fld)=i
         mg_mask_index   (l,mg_fld)=i
         i=i+mg_nh(l)*mg_nhz(l)*2*ndim*nelv
         if(i .gt. lmgs*lmg_rwt*2*ldim*lelv) then
            itmp = i/(2*ldim*lelv)
            write(6,*) 'parameter lmg_rwt too small',i,itmp,lmg_rwt
            call exitt
         endif
         call hsmg_setup_rstr_wt(
     $           mg_rstr_wt(mg_rstr_wt_index(l,mg_fld))
     $          ,mg_nh(l),mg_nh(l),mg_nhz(l),l,mg_work)
         call hsmg_setup_mask(
     $           mg_mask(mg_mask_index(l,mg_fld))
     $          ,mg_nh(l),mg_nh(l),mg_nhz(l),l,mg_work)
      enddo
      mg_mask_index(l,mg_fld)=i
      end
c----------------------------------------------------------------------
      subroutine hsmg_intp(uf,uc,l) ! l is coarse level
      real uf(1),uc(1)
      integer l

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 229 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 229 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 230 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 230 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      call hsmg_tnsr(uf,mg_nh(l+1),uc,mg_nh(l),mg_jh(1,l),mg_jht(1,l))
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_rstr(uc,uf,l) ! l is coarse level
      real uf(1),uc(1)
      integer l

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 238 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 238 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 239 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 239 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      if(l.ne.mg_lmax-1)
     $   call hsmg_do_wt(uf,mg_rstr_wt(mg_rstr_wt_index(l+1,mg_fld))
     $                     ,mg_nh(l+1),mg_nh(l+1),mg_nhz(l+1))
      call hsmg_tnsr(uc,mg_nh(l),uf,mg_nh(l+1),mg_jht(1,l),mg_jh(1,l))
      call hsmg_dssum(uc,l)
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_rstr_no_dssum(uc,uf,l) ! l is coarse level
      real uf(1),uc(1)
      integer l

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 251 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 251 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 252 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 252 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      if(l.ne.mg_lmax-1)
     $   call hsmg_do_wt(uf,mg_rstr_wt(mg_rstr_wt_index(l+1,mg_fld))
     $                     ,mg_nh(l+1),mg_nh(l+1),mg_nhz(l+1))
      call hsmg_tnsr(uc,mg_nh(l),uf,mg_nh(l+1),mg_jht(1,l),mg_jh(1,l))
      return
      end
c----------------------------------------------------------------------
c     computes
c     v = [A (x) A] u      or
c     v = [A (x) A (x) A] u 
      subroutine hsmg_tnsr(v,nv,u,nu,A,At)
      integer nv,nu
      real v(1),u(1),A(1),At(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 266 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 266 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 267 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 267 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      if (.not. if3d) then
         call hsmg_tnsr2d(v,nv,u,nu,A,At)
      else
         call hsmg_tnsr3d(v,nv,u,nu,A,At,At)
      endif
      return
      end
c----------------------------------------------------------------------
c     computes
c              T
c     v = A u B
      subroutine hsmg_tnsr2d(v,nv,u,nu,A,Bt)
      integer nv,nu
      real v(nv*nv,nelv),u(nu*nu,nelv),A(1),Bt(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 282 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 282 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      common /hsmgw/ work((lx1+2)*(lx1+2))
      integer ie
      do ie=1,nelv
         call mxm(A,nv,u(1,ie),nu,work,nu)
         call mxm(work,nv,Bt,nu,v(1,ie),nv)
      enddo
      return
      end
c----------------------------------------------------------------------
c     computes
c              
c     v = [C (x) B (x) A] u
      subroutine hsmg_tnsr3d(v,nv,u,nu,A,Bt,Ct)
      integer nv,nu
      real v(nv*nv*nv,nelv),u(nu*nu*nu,nelv),A(1),Bt(1),Ct(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 298 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 298 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter (lwk=(lx1+2)*(ly1+2)*(lz1+2))
      common /hsmgw/ work(0:lwk-1),work2(0:lwk-1)
      integer ie, i
      do ie=1,nelv
         call mxm(A,nv,u(1,ie),nu,work,nu*nu)
         do i=0,nu-1
            call mxm(work(nv*nu*i),nv,Bt,nu,work2(nv*nv*i),nv)
         enddo
         call mxm(work2,nv*nv,Ct,nu,v(1,ie),nv)
      enddo
      return
      end
c----------------------------------------------------------------------
c     computes
c              T
c     v = A u B
      subroutine hsmg_tnsr2d_el(v,nv,u,nu,A,Bt)
      integer nv,nu
      real v(nv*nv),u(nu*nu),A(1),Bt(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 318 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 318 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      common /hsmgw/ work((lx1+2)*(lx1+2))
c     
      call mxm(A,nv,u,nu,work,nu)
      call mxm(work,nv,Bt,nu,v,nv)
c     
      return
      end
c----------------------------------------------------------------------
c     computes
c              
c     v = [C (x) B (x) A] u
      subroutine hsmg_tnsr3d_el(v,nv,u,nu,A,Bt,Ct)
      integer nv,nu
      real v(nv*nv*nv),u(nu*nu*nu),A(1),Bt(1),Ct(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 333 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 333 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter (lwk=(lx1+2)*(ly1+2)*(lz1+2))
      common /hsmgw/ work(0:lwk-1),work2(0:lwk-1)
      integer i
c     
      call mxm(A,nv,u,nu,work,nu*nu)
      do i=0,nu-1
         call mxm(work(nv*nu*i),nv,Bt,nu,work2(nv*nv*i),nv)
      enddo
      call mxm(work2,nv*nv,Ct,nu,v,nv)
c     
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_dssum(u,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 349 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 349 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 350 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 350 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 351 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 351 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      if (ifsync) call nekgsync()

# 354
      etime1=dnekclock()

# 356
      call gs_op(mg_gsh_handle(l,mg_fld),u,1,1,0)

# 358
      tdadd =tdadd + dnekclock()-etime1

      
# 361
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_dsprod(u,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 366 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 366 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 367 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 367 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 368 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 368 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real u(1)
      
      if (ifsync) call nekgsync()
      
      call gs_op(mg_gsh_handle(l,mg_fld),u,1,2,0)
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_dssum(u,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 378 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 378 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 379 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 379 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 380 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 380 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      if (ifsync) call nekgsync()

# 383
      etime1=dnekclock()

# 385
      call gs_op(mg_gsh_schwarz_handle(l,mg_fld),u,1,1,0)

# 387
      tdadd =tdadd + dnekclock()-etime1

# 389
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_extrude(arr1,l1,f1,arr2,l2,f2,nx,ny,nz)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 394 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 394 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 395 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 395 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer l1,l2,nx,ny,nz
      real arr1(nx,ny,nz,nelv),arr2(nx,ny,nz,nelv)
      real f1,f2
      
      integer i,j,k,ie,i0,i1
      i0=2
      i1=nx-1
      
      if(.not.if3d) then
         do ie=1,nelv
            do j=i0,i1
               arr1(l1+1 ,j,1,ie) = f1*arr1(l1+1 ,j,1,ie)
     $                             +f2*arr2(l2+1 ,j,1,ie)
               arr1(nx-l1,j,1,ie) = f1*arr1(nx-l1,j,1,ie)
     $                             +f2*arr2(nx-l2,j,1,ie)
            enddo
            do i=i0,i1
               arr1(i,l1+1 ,1,ie) = f1*arr1(i,l1+1 ,1,ie)
     $                             +f2*arr2(i,l2+1 ,1,ie)
               arr1(i,ny-l1,1,ie) = f1*arr1(i,ny-l1,1,ie)
     $                             +f2*arr2(i,nx-l2,1,ie)
            enddo
         enddo
      else
         do ie=1,nelv
            do k=i0,i1
            do j=i0,i1
               arr1(l1+1 ,j,k,ie) = f1*arr1(l1+1 ,j,k,ie)
     $                             +f2*arr2(l2+1 ,j,k,ie)
               arr1(nx-l1,j,k,ie) = f1*arr1(nx-l1,j,k,ie)
     $                             +f2*arr2(nx-l2,j,k,ie)
            enddo
            enddo
            do k=i0,i1
            do i=i0,i1
               arr1(i,l1+1 ,k,ie) = f1*arr1(i,l1+1 ,k,ie)
     $                             +f2*arr2(i,l2+1 ,k,ie)
               arr1(i,nx-l1,k,ie) = f1*arr1(i,nx-l1,k,ie)
     $                             +f2*arr2(i,nx-l2,k,ie)
            enddo
            enddo
            do j=i0,i1
            do i=i0,i1
               arr1(i,j,l1+1 ,ie) = f1*arr1(i,j,l1+1 ,ie)
     $                             +f2*arr2(i,j,l2+1 ,ie)
               arr1(i,j,nx-l1,ie) = f1*arr1(i,j,nx-l1,ie)
     $                             +f2*arr2(i,j,nx-l2,ie)
            enddo
            enddo
         enddo
      endif
      return
      end
      
c----------------------------------------------------------------------
      subroutine h1mg_schwarz(e,r,sigma,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 452 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 452 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 453 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 453 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real e(1),r(1)
      
      n = mg_h1_n(l,mg_fld)
      
      call h1mg_schwarz_part1 (e,r,l)
      call hsmg_schwarz_wt    (e,l)          ! e  := W e
      call cmult              (e,sigma,n)    !  l       l
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_schwarz_part1 (e,r,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 467 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 467 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 468 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 468 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 469 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 469 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 470 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 470 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real e(1),r(1)
      
      integer enx,eny,enz,pm
      
      zero =  0
      one  =  1
      onem = -1
      
      n  = mg_h1_n (l,mg_fld)
      pm = p_mg_msk(l,mg_fld)
      
      call h1mg_mask  (r,mg_imask(pm),nelfld(ifield))  ! Zero Dirichlet 
      
      if (if3d) then ! extended array 
         call hsmg_schwarz_toext3d(mg_work,r,mg_nh(l))
      else
         call hsmg_schwarz_toext2d(mg_work,r,mg_nh(l))
      endif
      
      enx=mg_nh(l)+2
      eny=mg_nh(l)+2
      enz=mg_nh(l)+2
      if(.not.if3d) enz=1
      i = enx*eny*enz*nelv+1
      
c     exchange interior nodes
      call hsmg_extrude(mg_work,0,zero,mg_work,2,one,enx,eny,enz)
      call hsmg_schwarz_dssum(mg_work,l)
      call hsmg_extrude(mg_work,0,one ,mg_work,2,onem,enx,eny,enz)
      
      call hsmg_fdm(mg_work(i),mg_work,l) ! Do the local solves
      
c     Sum overlap region (border excluded)
      call hsmg_extrude(mg_work,0,zero,mg_work(i),0,one ,enx,eny,enz)
      call hsmg_schwarz_dssum(mg_work(i),l)
      call hsmg_extrude(mg_work(i),0,one ,mg_work,0,onem,enx,eny,enz)
      call hsmg_extrude(mg_work(i),2,one,mg_work(i),0,one,enx,eny,enz)
      
      if(.not.if3d) then ! Go back to regular size array
         call hsmg_schwarz_toreg2d(e,mg_work(i),mg_nh(l))
      else
         call hsmg_schwarz_toreg3d(e,mg_work(i),mg_nh(l))
      endif
      
      call hsmg_dssum(e,l)                           ! sum border nodes
      call h1mg_mask (e,mg_imask(pm),nelfld(ifield)) ! apply mask 
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz(e,r,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 523 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 523 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 524 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 524 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 525 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 525 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real e(1),r(1)
      integer l
      integer enx,eny,enz
      integer i
      
      real zero,one,onem
      zero =  0
      one  =  1
      onem = -1
      
c     apply mask (zeros Dirichlet nodes)
      !!!!! uncommenting
      call hsmg_do_wt(r,mg_mask(mg_mask_index(l,mg_fld)),
     $                mg_nh(l),mg_nh(l),mg_nhz(l))
      
c     go to extended size array (room for overlap)      
      if (if3d) then
         call hsmg_schwarz_toext3d(mg_work,r,mg_nh(l))
      else
         call hsmg_schwarz_toext2d(mg_work,r,mg_nh(l))
      endif
      
      enx=mg_nh(l)+2
      eny=mg_nh(l)+2
      enz=mg_nh(l)+2
      if(.not.if3d) enz=1
      i = enx*eny*enz*nelv+1
      
c     exchange interior nodes
      call hsmg_extrude(mg_work,0,zero,mg_work,2,one,enx,eny,enz)
      call hsmg_schwarz_dssum(mg_work,l)
      call hsmg_extrude(mg_work,0,one ,mg_work,2,onem,enx,eny,enz)
      
c     do the local solves
      call hsmg_fdm(mg_work(i),mg_work,l)
c     sum overlap region (border excluded)
      call hsmg_extrude(mg_work,0,zero,mg_work(i),0,one ,enx,eny,enz)
      call hsmg_schwarz_dssum(mg_work(i),l)
      call hsmg_extrude(mg_work(i),0,one ,mg_work,0,onem,enx,eny,enz)
      call hsmg_extrude(mg_work(i),2,one,mg_work(i),0,one,enx,eny,enz)
c     go back to regular size array
      if(.not.if3d) then
         call hsmg_schwarz_toreg2d(e,mg_work(i),mg_nh(l))
      else
         call hsmg_schwarz_toreg3d(e,mg_work(i),mg_nh(l))
      endif
c     sum border nodes
      call hsmg_dssum(e,l)
c     apply mask (zeros Dirichlet nodes)
      !!!!!! changing r to e
      call hsmg_do_wt(e,mg_mask(mg_mask_index(l,mg_fld)),
     $                mg_nh(l),mg_nh(l),mg_nhz(l))
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_toext2d(a,b,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 582 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 582 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real a(0:n+1,0:n+1,nelv),b(n,n,nelv)
      
      integer i,j,ie
c      call rzero(a,(n+2)*(n+2)*nelv)
      do ie=1,nelv
         do i=0,n+1
            a(i,0,ie)=0.
         enddo
         do j=1,n
            a(0  ,j,ie)=0.
            do i=1,n
               a(i,j,ie)=b(i,j,ie)
            enddo
            a(n+1,j,ie)=0.
         enddo
         do i=0,n+1
            a(i,n+1,ie)=0.
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_toext3d(a,b,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 607 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 607 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real a(0:n+1,0:n+1,0:n+1,nelv),b(n,n,n,nelv)
      
      integer i,j,k,ie
      call rzero(a,(n+2)*(n+2)*(n+2)*nelv)
      do ie=1,nelv
      do k=1,n
      do j=1,n
      do i=1,n
         a(i,j,k,ie)=b(i,j,k,ie)
      enddo
      enddo
      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_toreg2d(b,a,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 626 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 626 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real a(0:n+1,0:n+1,nelv),b(n,n,nelv)
      
      integer i,j,ie
      do ie=1,nelv
      do j=1,n
      do i=1,n
         b(i,j,ie)=a(i,j,ie)
      enddo
      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_toreg3d(b,a,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 642 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 642 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real a(0:n+1,0:n+1,0:n+1,nelv),b(n,n,n,nelv)
      
      integer i,j,k,ie
      do ie=1,nelv
      do k=1,n
      do j=1,n
      do i=1,n
         b(i,j,k,ie)=a(i,j,k,ie)
      enddo
      enddo
      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_fdm()

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 660 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 660 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 661 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 661 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 662 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 662 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer l,i,j,nl
      i = mg_fast_s_index(mg_lmax,mg_fld-1)
      j = mg_fast_d_index(mg_lmax,mg_fld-1)
      do l=2,mg_lmax
         mg_fast_s_index(l,mg_fld)=i
         nl = mg_nh(l)+2
         i=i+nl*nl*2*ndim*nelv
         if(i .gt. lmg_fasts*2*ldim*lelv) then
            itmp = i/(2*ldim*lelv)
            write(6,*) 'lmg_fasts too small',i,itmp,lmg_fasts,l
            call exitt
         endif
         mg_fast_d_index(l,mg_fld)=j
         j=j+(nl**ndim)*nelv
         if(j .gt. lmg_fastd*lelv) then
            itmp = i/(2*ldim*lelv)
            write(6,*) 'lmg_fastd too small',i,itmp,lmg_fastd,l
            call exitt
         endif
         call hsmg_setup_fast(
     $             mg_fast_s(mg_fast_s_index(l,mg_fld))
     $            ,mg_fast_d(mg_fast_d_index(l,mg_fld))
     $            ,mg_nh(l)+2,mg_ah(1,l),mg_bh(1,l),mg_nx(l))
      enddo
      mg_fast_s_index(l,mg_fld)=i
      mg_fast_d_index(l,mg_fld)=j
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_fdm()

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 694 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 694 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 695 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 695 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 696 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 696 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer l,i,j,nl
      i = mg_fast_s_index(mg_lmax,mg_fld-1)
      j = mg_fast_d_index(mg_lmax,mg_fld-1)
      do l=2,mg_lmax-1
         mg_fast_s_index(l,mg_fld)=i
         nl = mg_nh(l)+2
         i=i+nl*nl*2*ndim*nelv
         if(i .gt. lmg_fasts*2*ldim*lelv) then
            itmp = i/(2*ldim*lelv)
            write(6,*) 'lmg_fasts too small',i,itmp,lmg_fasts,l
            call exitt
         endif
         mg_fast_d_index(l,mg_fld)=j
         j=j+(nl**ndim)*nelv
         if(j .gt. lmg_fastd*lelv) then
            itmp = i/(2*ldim*lelv)
            write(6,*) 'lmg_fastd too small',i,itmp,lmg_fastd,l
            call exitt
         endif
         call hsmg_setup_fast(
     $             mg_fast_s(mg_fast_s_index(l,mg_fld))
     $            ,mg_fast_d(mg_fast_d_index(l,mg_fld))
     $            ,mg_nh(l)+2,mg_ah(1,l),mg_bh(1,l),mg_nx(l))
      enddo
      mg_fast_s_index(l,mg_fld)=i
      mg_fast_d_index(l,mg_fld)=j
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_fast(s,d,nl,ah,bh,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 728 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 728 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 729 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 729 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 730 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 730 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real s(nl*nl,2,ndim,nelv)
      real d(nl**ndim,nelv)
      real ah(1),bh(1)
      common /ctmpf/  lr(2*lx1+4),ls(2*lx1+4),lt(2*lx1+4)
     $              , llr(lelt),lls(lelt),llt(lelt)
     $              , lmr(lelt),lms(lelt),lmt(lelt)
     $              , lrr(lelt),lrs(lelt),lrt(lelt)
      real lr ,ls ,lt
      real llr,lls,llt
      real lmr,lms,lmt
      real lrr,lrs,lrt
      
      integer i,j,k
      integer ie,il,nr,ns,nt
      integer lbr,rbr,lbs,rbs,lbt,rbt
      real eps,diag
      
      ierr = 0
      do ie=1,nelv
         call get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,2,ierr)
         nr=nl
         ns=nl
         nt=nl
         call hsmg_setup_fast1d(s(1,1,1,ie),lr,nr,lbr,rbr
     $            ,llr(ie),lmr(ie),lrr(ie),ah,bh,n,ie)
         call hsmg_setup_fast1d(s(1,1,2,ie),ls,ns,lbs,rbs
     $            ,lls(ie),lms(ie),lrs(ie),ah,bh,n,ie)
         if(if3d) call hsmg_setup_fast1d(s(1,1,3,ie),lt,nt,lbt,rbt
     $                     ,llt(ie),lmt(ie),lrt(ie),ah,bh,n,ie)
         il=1
         if(.not.if3d) then
            eps = 1.e-5*(vlmax(lr(2),nr-2) + vlmax(ls(2),ns-2))
            do j=1,ns
            do i=1,nr
               diag = lr(i)+ls(j)
               if (diag.gt.eps) then
                  d(il,ie) = 1.0/diag
               else
c                 write(6,2) ie,'Reset Eig in hsmg setup fast:',i,j,l
c    $                         ,eps,diag,lr(i),ls(j)
    2             format(i6,1x,a21,3i5,1p4e12.4)
                  d(il,ie) = 0.0
               endif
               il=il+1
            enddo
            enddo
         else
            eps = 1.e-5 * (vlmax(lr(2),nr-2)
     $                  + vlmax(ls(2),ns-2) + vlmax(lt(2),nt-2))
            do k=1,nt
            do j=1,ns
            do i=1,nr
               diag = lr(i)+ls(j)+lt(k)
               if (diag.gt.eps) then
                  d(il,ie) = 1.0/diag
               else
c                 write(6,3) ie,'Reset Eig in hsmg setup fast:',i,j,k,l
c    $                         ,eps,diag,lr(i),ls(j),lt(k)
    3             format(i6,1x,a21,4i5,1p5e12.4)
                  d(il,ie) = 0.0
               endif
               il=il+1
            enddo
            enddo
            enddo
         endif
      enddo
      
      ierrmx = iglmax(ierr,1)
      if (ierrmx.gt.0) then
         if (ierr.gt.0) write(6,*) nid,ierr,' BC FAIL'
         call exitti('A INVALID BC FOUND in genfast$',ierrmx)
      endif
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_fast1d(s,lam,nl,lbc,rbc,ll,lm,lr,ah,bh,n,ie)
      integer nl,lbc,rbc,n
      real s(nl,nl,2),lam(nl),ll,lm,lr
      real ah(0:n,0:n),bh(0:n)
      

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 813 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 813 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter(lxm=lx1+2)
      common /ctmp0/ b(2*lxm*lxm),w(2*lxm*lxm)
      
      call hsmg_setup_fast1d_a(s,lbc,rbc,ll,lm,lr,ah,n)
      call hsmg_setup_fast1d_b(b,lbc,rbc,ll,lm,lr,bh,n)
      
c     if (nid.eq.0) write(6,*) 'THIS is generalev call',nl,lbc
      call generalev(s,b,lam,nl,w)
      if(lbc.gt.0) call row_zero(s,nl,nl,1)
      if(lbc.eq.1) call row_zero(s,nl,nl,2)
      if(rbc.gt.0) call row_zero(s,nl,nl,nl)
      if(rbc.eq.1) call row_zero(s,nl,nl,nl-1)
      
      call transpose(s(1,1,2),nl,s,nl)
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_fast1d_a(a,lbc,rbc,ll,lm,lr,ah,n)
      integer lbc,rbc,n
      real a(0:n+2,0:n+2),ll,lm,lr
      real ah(0:n,0:n)
      
      real fac
      integer i,j,i0,i1
      i0=0
      if(lbc.eq.1) i0=1
      i1=n
      if(rbc.eq.1) i1=n-1
      
      call rzero(a,(n+3)*(n+3))
      fac = 2.0/lm
      a(1,1)=1.0
      a(n+1,n+1)=1.0
      do j=i0,i1
         do i=i0,i1
            a(i+1,j+1)=fac*ah(i,j)
         enddo
      enddo
      if(lbc.eq.0) then
         fac = 2.0/ll
         a(0,0)=fac*ah(n-1,n-1)
         a(1,0)=fac*ah(n  ,n-1)
         a(0,1)=fac*ah(n-1,n  )
         a(1,1)=a(1,1)+fac*ah(n  ,n  )
      else
         a(0,0)=1.0
      endif
      if(rbc.eq.0) then
         fac = 2.0/lr
         a(n+1,n+1)=a(n+1,n+1)+fac*ah(0,0)
         a(n+2,n+1)=fac*ah(1,0)
         a(n+1,n+2)=fac*ah(0,1)
         a(n+2,n+2)=fac*ah(1,1)
      else
         a(n+2,n+2)=1.0
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_fast1d_b(b,lbc,rbc,ll,lm,lr,bh,n)
      integer lbc,rbc,n
      real b(0:n+2,0:n+2),ll,lm,lr
      real bh(0:n)
      
      real fac
      integer i,j,i0,i1
      i0=0
      if(lbc.eq.1) i0=1
      i1=n
      if(rbc.eq.1) i1=n-1
      
      call rzero(b,(n+3)*(n+3))
      fac = 0.5*lm
      b(1,1)=1.0
      b(n+1,n+1)=1.0
      do i=i0,i1
         b(i+1,i+1)=fac*bh(i)
      enddo
      if(lbc.eq.0) then
         fac = 0.5*ll
         b(0,0)=fac*bh(n-1)
         b(1,1)=b(1,1)+fac*bh(n  )
      else
         b(0,0)=1.0
      endif
      if(rbc.eq.0) then
         fac = 0.5*lr
         b(n+1,n+1)=b(n+1,n+1)+fac*bh(0)
         b(n+2,n+2)=fac*bh(1)
      else
         b(n+2,n+2)=1.0
      endif
      return
      end
c----------------------------------------------------------------------
c     clobbers r
      subroutine hsmg_fdm(e,r,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 911 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 911 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 912 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 912 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 913 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 913 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      call hsmg_do_fast(e,r,
     $      mg_fast_s(mg_fast_s_index(l,mg_fld)),
     $      mg_fast_d(mg_fast_d_index(l,mg_fld)),
     $      mg_nh(l)+2)
      return
      end
c----------------------------------------------------------------------
c     clobbers r
      subroutine hsmg_do_fast(e,r,s,d,nl)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 923 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 923 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 924 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 924 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real e(nl**ndim,nelv)
      real r(nl**ndim,nelv)
      real s(nl*nl,2,ndim,nelv)
      real d(nl**ndim,nelv)
      
      integer ie,nn,i
      nn=nl**ndim
      if(.not.if3d) then
         do ie=1,nelv
            call hsmg_tnsr2d_el(e(1,ie),nl,r(1,ie),nl
     $                         ,s(1,2,1,ie),s(1,1,2,ie))
            do i=1,nn
               r(i,ie)=d(i,ie)*e(i,ie)
            enddo
            call hsmg_tnsr2d_el(e(1,ie),nl,r(1,ie),nl
     $                         ,s(1,1,1,ie),s(1,2,2,ie))
         enddo
      else
         do ie=1,nelv
            call hsmg_tnsr3d_el(e(1,ie),nl,r(1,ie),nl
     $                         ,s(1,2,1,ie),s(1,1,2,ie),s(1,1,3,ie))
            do i=1,nn
               r(i,ie)=d(i,ie)*e(i,ie)
            enddo
            call hsmg_tnsr3d_el(e(1,ie),nl,r(1,ie),nl
     $                         ,s(1,1,1,ie),s(1,2,2,ie),s(1,2,3,ie))
         enddo
      endif
      return
      end
c----------------------------------------------------------------------
c     u = wt .* u
      subroutine hsmg_do_wt(u,wt,nx,ny,nz)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 958 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 958 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 959 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 959 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer nx,ny,nz
      real u(nx,ny,nz,nelv)
      real wt(nx,nz,2,ndim,nelv)
      
      integer e
      
c     if (nx.eq.2) then
c        do e=1,nelv
c           call outmat(wt(1,1,1,1,e),nx,nz,'wt 1-1',e)
c           call outmat(wt(1,1,2,1,e),nx,nz,'wt 2-1',e)
c           call outmat(wt(1,1,1,2,e),nx,nz,'wt 1-2',e)
c           call outmat(wt(1,1,2,2,e),nx,nz,'wt 2-2',e)
c        enddo
c        call exitti('hsmg_do_wt quit$',nelv)
c     endif
      
      if (.not. if3d) then
         do ie=1,nelv
            do j=1,ny
               u( 1,j,1,ie)=u( 1,j,1,ie)*wt(j,1,1,1,ie)
               u(nx,j,1,ie)=u(nx,j,1,ie)*wt(j,1,2,1,ie)
            enddo
            do i=2,nx-1
               u(i, 1,1,ie)=u(i, 1,1,ie)*wt(i,1,1,2,ie)
               u(i,ny,1,ie)=u(i,ny,1,ie)*wt(i,1,2,2,ie)
            enddo
         enddo
      else
         do ie=1,nelv
            do k=1,nz
            do j=1,ny
               u( 1,j,k,ie)=u( 1,j,k,ie)*wt(j,k,1,1,ie)
               u(nx,j,k,ie)=u(nx,j,k,ie)*wt(j,k,2,1,ie)
            enddo
            enddo
            do k=1,nz
            do i=2,nx-1
               u(i, 1,k,ie)=u(i, 1,k,ie)*wt(i,k,1,2,ie)
               u(i,ny,k,ie)=u(i,ny,k,ie)*wt(i,k,2,2,ie)
            enddo
            enddo
            do j=2,ny-1
            do i=2,nx-1
               u(i,j, 1,ie)=u(i,j, 1,ie)*wt(i,j,1,3,ie)
               u(i,j,nz,ie)=u(i,j,nz,ie)*wt(i,j,2,3,ie)
            enddo
            enddo
         enddo
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_rstr_wt(wt,nx,ny,nz,l,w)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1013 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1013 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1014 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1014 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer nx,ny,nz,l
      real w(nx,ny,nz,nelv)
      real wt(nx,nz,2,ndim,nelv)
      
      integer ie
      !init border nodes to 1
      call rzero(w,nx*ny*nz*nelv)
c     print *, 'Setup rstr wt: ',nx,ny,nz,nelv
      if (.not.if3d) then
         do ie=1,nelv
            do i=1,nx
               w(i,1,1,ie)=1.0
               w(i,ny,1,ie)=1.0
            enddo
            do j=1,ny
               w(1,j,1,ie)=1.0
               w(nx,j,1,ie)=1.0
            enddo
         enddo
      else
         do ie=1,nelv
            do j=1,ny
            do i=1,nx
               w(i,j,1,ie)=1.0
               w(i,j,nz,ie)=1.0
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               w(i,1,k,ie)=1.0
               w(i,ny,k,ie)=1.0
            enddo
            enddo
            do k=1,nz
            do j=1,ny
               w(1,j,k,ie)=1.0
               w(nx,j,k,ie)=1.0
            enddo
            enddo
         enddo
      endif
      call hsmg_dssum(w,l)
      !invert the count w to get the weight wt
      if (.not. if3d) then
         do ie=1,nelv
            do j=1,ny
               wt(j,1,1,1,ie)=1.0/w(1,j,1,ie)
               wt(j,1,2,1,ie)=1.0/w(nx,j,1,ie)
            enddo
            do i=1,nx
               wt(i,1,1,2,ie)=1.0/w(i,1,1,ie)
               wt(i,1,2,2,ie)=1.0/w(i,ny,1,ie)
            enddo
         enddo
      else
         do ie=1,nelv
            do k=1,nz
            do j=1,ny
               wt(j,k,1,1,ie)=1.0/w(1,j,k,ie)
               wt(j,k,2,1,ie)=1.0/w(nx,j,k,ie)
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               wt(i,k,1,2,ie)=1.0/w(i,1,k,ie)
               wt(i,k,2,2,ie)=1.0/w(i,ny,k,ie)
            enddo
            enddo
            do j=1,ny
            do i=1,nx
               wt(i,j,1,3,ie)=1.0/w(i,j,1,ie)
               wt(i,j,2,3,ie)=1.0/w(i,j,nz,ie)
            enddo
            enddo
         enddo
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_mask(wt,nx,ny,nz,l,w)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1095 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1095 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1096 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1096 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer nx,ny,nz,l
      real w(nx,ny,nz,nelv)
      real wt(nx,nz,2,ndim,nelv)
      
      integer ie
      integer lbr,rbr,lbs,rbs,lbt,rbt
c     init everything to 1
      
      n = nx*ny*nz*nelv
      call rone(w,n)
      
c     set dirichlet nodes to zero
      ierr = 0
      do ie=1,nelv
         call get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,2,ierr)
         if (ierr.ne.0) then
            ierr = -1
            call get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,2,ierr)
         endif
      
         if(lbr.eq.1) then
            do k=1,nz
            do j=1,ny
               w(1,j,k,ie)=0.0
            enddo
            enddo
         endif
         if(rbr.eq.1) then
            do k=1,nz
            do j=1,ny
               w(nx,j,k,ie)=0.0
            enddo
            enddo
         endif
         if(lbs.eq.1) then
            do k=1,nz
            do i=1,nx
               w(i,1,k,ie)=0.0
            enddo
            enddo
         endif
         if(rbs.eq.1) then
            do k=1,nz
            do i=1,nx
               w(i,ny,k,ie)=0.0
            enddo
            enddo
         endif
         if(if3d) then
            if(lbt.eq.1) then
               do j=1,ny
               do i=1,nx
                  w(i,j,1,ie)=0.0
               enddo
               enddo
            endif
            if(rbt.eq.1) then
               do j=1,ny
               do i=1,nx
                  w(i,j,nz,ie)=0.0
               enddo
               enddo
            endif
         endif
      enddo
c     do direct stiffness multiply
      
      call hsmg_dsprod(w,l)
      
      
c     store weight
      if (.not. if3d) then
         do ie=1,nelv
            do j=1,ny
               wt(j,1,1,1,ie)=w(1,j,1,ie)
               wt(j,1,2,1,ie)=w(nx,j,1,ie)
            enddo
            do i=1,nx
               wt(i,1,1,2,ie)=w(i,1,1,ie)
               wt(i,1,2,2,ie)=w(i,ny,1,ie)
            enddo
         enddo
      else
         do ie=1,nelv
            do k=1,nz
            do j=1,ny
               wt(j,k,1,1,ie)=w(1,j,k,ie)
               wt(j,k,2,1,ie)=w(nx,j,k,ie)
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               wt(i,k,1,2,ie)=w(i,1,k,ie)
               wt(i,k,2,2,ie)=w(i,ny,k,ie)
            enddo
            enddo
            do k=1,nz
            do j=1,ny
               wt(j,k,1,3,ie)=w(i,j,1,ie)
               wt(j,k,2,3,ie)=w(i,j,nz,ie)
            enddo
            enddo
         enddo
      endif
      
      ierrmx = iglmax(ierr,1)
      if (ierrmx.gt.0) then
         if (ierr.gt.0) write(6,*) nid,ierr,' BC FAIL'
         call exitti('B INVALID BC FOUND in genfast$',ierrmx)
      endif
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_schwarz_wt(ifsqrt)
      logical ifsqrt

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1213 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1213 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1214 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1214 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1215 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1215 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer l,i,nl,nlz
      
      i = mg_schwarz_wt_index(mg_lmax,mg_fld-1)
      do l=2,mg_lmax-1
         mg_schwarz_wt_index(l,mg_fld)=i
         nl = mg_nh(l)
         nlz = mg_nh(l)
         if(.not.if3d) nlz=1
         i=i+nl*nlz*4*ndim*nelv
         if(i .gt. lmg_swt*4*ldim*lelv) then
            itmp = i/(4*ldim*lelv)
            write(6,*) 'lmg_swt too small',i,itmp,lmg_swt,l
            call exitt
         endif
      
         call h1mg_setup_schwarz_wt_1(
     $      mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),l,ifsqrt)
      
      enddo
      mg_schwarz_wt_index(l,mg_fld)=i
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_schwarz_wt(ifsqrt)
      logical ifsqrt

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1243 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1243 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1244 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1244 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1245 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1245 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer l,i,nl,nlz
      
      i = mg_schwarz_wt_index(mg_lmax,mg_fld-1)
      do l=2,mg_lmax
      
         mg_schwarz_wt_index(l,mg_fld)=i
         nl  = mg_nh(l)
         nlz = mg_nhz(l)
         i   = i+nl*nlz*4*ndim*nelv
      
         if (i .gt. lmg_swt*4*ldim*lelv) then
            itmp = i/(4*ldim*lelv)
            write(6,*) 'lmg_swt too small',i,itmp,lmg_swt,l
            call exitt
         endif
      
         call h1mg_setup_schwarz_wt_1(
     $      mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),l,ifsqrt)
      
      enddo
      
      mg_schwarz_wt_index(l,mg_fld)=i
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_wt(e,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1274 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1274 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1275 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1275 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1276 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1276 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      if(.not.if3d) call hsmg_schwarz_wt2d(
     $    e,mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),mg_nh(l))
      if(if3d) call hsmg_schwarz_wt3d(
     $    e,mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),mg_nh(l))
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_wt2d(e,wt,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1286 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1286 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real e(n,n,nelv)
      real wt(n,4,2,nelv)
      
      integer ie,i,j
      do ie=1,nelv
         do j=1,n
            e(1  ,j,ie)=e(1  ,j,ie)*wt(j,1,1,ie)
            e(2  ,j,ie)=e(2  ,j,ie)*wt(j,2,1,ie)
            e(n-1,j,ie)=e(n-1,j,ie)*wt(j,3,1,ie)
            e(n  ,j,ie)=e(n  ,j,ie)*wt(j,4,1,ie)
         enddo
         do i=3,n-2
            e(i,1  ,ie)=e(i,1  ,ie)*wt(i,1,2,ie)
            e(i,2  ,ie)=e(i,2  ,ie)*wt(i,2,2,ie)
            e(i,n-1,ie)=e(i,n-1,ie)*wt(i,3,2,ie)
            e(i,n  ,ie)=e(i,n  ,ie)*wt(i,4,2,ie)
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_wt3d(e,wt,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1310 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1310 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real e(n,n,n,nelv)
      real wt(n,n,4,3,nelv)
      
      integer ie,i,j,k
      do ie=1,nelv
         do k=1,n
         do j=1,n
            e(1  ,j,k,ie)=e(1  ,j,k,ie)*wt(j,k,1,1,ie)
            e(2  ,j,k,ie)=e(2  ,j,k,ie)*wt(j,k,2,1,ie)
            e(n-1,j,k,ie)=e(n-1,j,k,ie)*wt(j,k,3,1,ie)
            e(n  ,j,k,ie)=e(n  ,j,k,ie)*wt(j,k,4,1,ie)
         enddo
         enddo
         do k=1,n
         do i=3,n-2
            e(i,1  ,k,ie)=e(i,1  ,k,ie)*wt(i,k,1,2,ie)
            e(i,2  ,k,ie)=e(i,2  ,k,ie)*wt(i,k,2,2,ie)
            e(i,n-1,k,ie)=e(i,n-1,k,ie)*wt(i,k,3,2,ie)
            e(i,n  ,k,ie)=e(i,n  ,k,ie)*wt(i,k,4,2,ie)
         enddo
         enddo
         do j=3,n-2
         do i=3,n-2
            e(i,j,1  ,ie)=e(i,j,1  ,ie)*wt(i,j,1,3,ie)
            e(i,j,2  ,ie)=e(i,j,2  ,ie)*wt(i,j,2,3,ie)
            e(i,j,n-1,ie)=e(i,j,n-1,ie)*wt(i,j,3,3,ie)
            e(i,j,n  ,ie)=e(i,j,n  ,ie)*wt(i,j,4,3,ie)
         enddo
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_coarse_solve(e,r)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1346 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1346 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DOMAIN" 1
c     
c     arrays for overlapping Schwartz algorithm
c     
# 4
      parameter (ltotd = lx1*ly1*lz1*lelt                     )
c     
      common /ddptri/ ndom,n_o,nel_proc,gs_hnd_overlap
     $              , na (lelt+1) , ma(lelt+1)
     $              , nza(lelt+1)
c     
      integer gs_hnd_overlap
c     
c     These are the H1 coarse-grid arrays:
c     
      parameter(lxc=2)
      parameter(lcr=lxc**ldim)
      common /h1_crsi/ se_to_gcrs(lcr,lelt)
     $               , n_crs,m_crs, nx_crs, nxyz_c
      integer*8 se_to_gcrs
c     
      common /h1_crs/  h1_basis(lx1*lxc),h1_basist(lxc*lx1)
     $               , h1_basis_acc(lx1,lxc),h1_basist_acc(lxc,lx1)
c     
      real             l2_basis(lx2*lxc),l2_basist(lxc*lx2)
      equivalence     (h1_basis  ,l2_basis  )
      equivalence     (h1_basist ,l2_basist )
c     
      real             l2_basis_acc(lx2,lxc),l2_basist_acc(lxc,lx2)
C      equivalence     (h1_basis_acc ,l2_basis_acc  )
C      equivalence     (h1_basist_acc ,l2_basist_acc )
# 1347 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1347 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/ESOLV" 1
# 1
      common /econst/ iesolv
      common /efastm/ ifalgn(lelv), ifrsxy(lelv)
      logical         ifalgn, ifrsxy
      common /eouter/ volel(lelv) 
# 1348 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1348 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 1349 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1349 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 1350 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1350 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 1351 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1351 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1352 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1352 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 1353 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1353 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1354 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1354 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1355 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1355 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real e(1),r(1)
c     
      integer n_crs_tot
      save    n_crs_tot
      data    n_crs_tot /0/
c     
      if (icalld.eq.0) then ! timer info
         ncrsl=0
         tcrsl=0.0
      endif
      icalld = 1
      
      if (ifsync) call nekgsync()
      
      ncrsl  = ncrsl  + 1

# 1371
      etime1=dnekclock()

      
# 1374
      call crs_solve(xxth(ifield),e,r)
      

# 1377
      tcrsl=tcrsl+dnekclock()-etime1

      
# 1380
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_solve

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1385 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1385 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1386 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1386 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer l,i,nl,nlz
      i = mg_solve_index(mg_lmax+1,mg_fld-1)
      do l=1,mg_lmax
         mg_solve_index(l,mg_fld)=i
         i=i+mg_nh(l)*mg_nh(l)*mg_nhz(l)*nelv
         if(i .gt. lmg_solve*lelv) then
            itmp = i/lelv
            write(6,*) 'lmg_solve too small',i,itmp,lmg_solve,l
            call exitt
         endif
      enddo
      mg_solve_index(l,mg_fld)=i
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_solve(e,r)
      real e(1),r(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1406 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1406 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1407 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1407 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 1408 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1408 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1409 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1409 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 1410 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1410 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 1411 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1411 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1412 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1412 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 1413 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1413 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 1414 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1414 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      common /quick/ ecrs  (2)  ! quick work array
     $             , ecrs2 (2)  ! quick work array
c     common /quick/ ecrs  (lx2*ly2*lz2*lelv)  ! quick work array
c    $             , ecrs2 (lx2*ly2*lz2*lelv)  ! quick work array
      
      common /scrhi/ h2inv (lx1,ly1,lz1,lelv)
      common /scrvh/ h1    (lx1,ly1,lz1,lelv),
     $               h2    (lx1,ly1,lz1,lelv)
      
      integer ilstep,iter
      save    ilstep,iter
      data    ilstep,iter /0,0/
      
      real    rhoavg,copt(2),copw(2)
      save    rhoavg,copt1,copt2
      data    rhoavg,copt1,copt2 /3*1./  ! Default copt = 1 for additive
      
      integer l,nt
      integer*8 ntotg,nxyz2
      
      logical if_hybrid
      
      mg_fld = 1
      if (ifield.gt.1) mg_fld = 2
      
      if (istep.ne.ilstep) then
         ilstep = istep
         ntot1  = nx1*ny1*nz1*nelv
         rhoavg = glsc2(vtrans,bm1,ntot1)/volvm1
      endif
      
      n = nx2*ny2*nz2*nelv
c     call copy(e,r,n)
c     return
      
      if (icalld.eq.0) then
      
         tddsl=0.0
         nddsl=0
      
         icalld = 1
         taaaa = 0
         tbbbb = 0
         tcccc = 0
         tdddd = 0
         teeee = 0
      endif
      
      nddsl  = nddsl  + 1

# 1465
      etime1 = dnekclock()

      
c     n = nx2*ny2*nz2*nelv
c     rmax = glmax(r,n)
c     if (nid.eq.0) write(6,*) istep,n,rmax,' rmax1'
       
# 1472
      iter = iter + 1      
      
      l = mg_lmax
      nt = mg_nh(l)*mg_nh(l)*mg_nhz(l)*nelv
      ! e := W M        r
      !         Schwarz
      time_0 = dnekclock()
      call local_solves_fdm(e,r)
      
      time_1 = dnekclock()
      
c     if (param(41).eq.1) if_hybrid = .true.
      if_hybrid = .false.
      
      if (if_hybrid) then
         ! w := E e
         rbd1dt = rhoavg*bd(1)/dt ! Assumes constant density!!!
         call cdabdtp(mg_work2,e,h1,h2,h2inv,1)
         call cmult  (mg_work2,rbd1dt,nt)
         time_2 = dnekclock()
         if (istep.eq.1) then
            copt(1)  = vlsc2(r       ,mg_work2,nt)
            copt(2)  = vlsc2(mg_work2,mg_work2,nt)
            call gop(copt,copw,'+  ', 2)
            copt(1)  = copt(1)/copt(2)
            avg2     = 1./iter
            avg1     = 1.-avg2
            copt1    = avg1*copt1 + avg2*copt(1)
            if(nid.eq.0)write(6,1)istep,iter,rbd1dt,copt(1),copt1,'cpt1'
    1       format(2i6,1p3e14.5,2x,a4)
         endif
         ! w := r - w
         do i = 1,nt
            mg_work2(i) = r(i) - copt1*mg_work2(i)
            e       (i) = copt1*e(i)
            ecrs2   (i) = mg_work2(i)
         enddo
      
      else   ! Additive
         ! w := r - w
         do i = 1,nt
            mg_work2(i) = r(i)
         enddo
         time_2 = dnekclock()
      endif
      
      do l = mg_lmax-1,2,-1
      
c        rmax = glmax(mg_work2,nt)
c        if (nid.eq.0) write(6,*) l,nt,rmax,' rmax2'
      
         nt = mg_nh(l)*mg_nh(l)*mg_nhz(l)*nelv
         !          T
         ! r   :=  J w
         !  l         
         call hsmg_rstr(mg_solve_r(mg_solve_index(l,mg_fld)),mg_work2,l)
      
         ! w  := r
         !        l
         call copy(mg_work2,mg_solve_r(mg_solve_index(l,mg_fld)),nt)
         ! e  := M        w
         !  l     Schwarz  
         call hsmg_schwarz(
     $          mg_solve_e(mg_solve_index(l,mg_fld)),mg_work2,l)
      
         ! e  := W e
         !  l       l
         call hsmg_schwarz_wt(mg_solve_e(mg_solve_index(l,mg_fld)),l)
      
c        call exitti('quit in mg$',l)
      
         ! w  := r  - w
         !        l
         do i = 0,nt-1
            mg_work2(i+1) = mg_solve_r(mg_solve_index(l,mg_fld)+i)
     $         !-alpha*mg_work2(i+1)
         enddo
      enddo
      
      call hsmg_rstr_no_dssum(
     $   mg_solve_r(mg_solve_index(1,mg_fld)),mg_work2,1)
      
      nzw = ndim-1
      
      call hsmg_do_wt(mg_solve_r(mg_solve_index(1,mg_fld)),
     $                mg_mask(mg_mask_index(1,mg_fld)),2,2,nzw)
      
      !        -1
      ! e  := A   r
      !  1         1
      call hsmg_coarse_solve(mg_solve_e(mg_solve_index(1,mg_fld)),
     $                       mg_solve_r(mg_solve_index(1,mg_fld)))
      
      call hsmg_do_wt(mg_solve_e(mg_solve_index(1,mg_fld)),
     $                mg_mask(mg_mask_index(1,mg_fld)),2,2,nzw)
      time_3 = dnekclock()
      do l = 2,mg_lmax-1
         nt = mg_nh(l)*mg_nh(l)*mg_nhz(l)*nelv
         ! w   :=  J e
         !            l-1
         call hsmg_intp
     $      (mg_work2,mg_solve_e(mg_solve_index(l-1,mg_fld)),l-1)
      
         ! e   :=  e  + w
         !  l       l
         do i = 0,nt-1
            mg_solve_e(mg_solve_index(l,mg_fld)+i) =
     $        + mg_solve_e(mg_solve_index(l,mg_fld)+i) + mg_work2(i+1)
         enddo
      enddo
      l = mg_lmax
      nt = mg_nh(l)*mg_nh(l)*mg_nhz(l)*nelv
      ! w   :=  J e
      !            m-1
      
      call hsmg_intp(mg_work2,
     $   mg_solve_e(mg_solve_index(l-1,mg_fld)),l-1)
      
      if (if_hybrid.and.istep.eq.1) then
         ! ecrs := E e_c
         call cdabdtp(ecrs,mg_work2,h1,h2,h2inv,1)
         call cmult  (ecrs,rbd1dt,nt)
         copt(1)  = vlsc2(ecrs2,ecrs,nt)
         copt(2)  = vlsc2(ecrs ,ecrs,nt)
         call gop(copt,copw,'+  ', 2)
         copt(1)  = copt(1)/copt(2)
         avg2     = 1./iter
         avg1     = 1.-avg2
         copt2    = avg1*copt2 + avg2*copt(1)
         if(nid.eq.0)write(6,1)istep,iter,rbd1dt,copt(1),copt2,'cpt2'
      endif
      ! e := e + w
      
      do i = 1,nt
         e(i) = e(i) + copt2*mg_work2(i)
      enddo
      time_4 = dnekclock()
c     print *, 'Did an MG iteration'
c     
      taaaa = taaaa + (time_1 - time_0)
      tbbbb = tbbbb + (time_2 - time_1)
      tcccc = tcccc + (time_3 - time_2)
      tdddd = tdddd + (time_4 - time_3)
      teeee = teeee + (time_4 - time_0)
c     
c     A typical time breakdown:
c     
c  1.3540E+01  5.4390E+01  1.1440E+01  1.2199E+00  8.0590E+01 HSMG time
c     
c  ==>  54/80 = 67 % of preconditioner time is in residual evaluation!
c     
      call ortho (e)
      

# 1626
      tddsl  = tddsl + ( dnekclock()-etime1 )

      
      
# 1630
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_setup_mg_nx()

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1635 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1635 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1636 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1636 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 1637 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1637 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1638 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1638 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SEMHAT" 1
# 1
      parameter (lr2=2*lx1*lx1)
      common /ahat/ ah (lr2),bh (lr2),ch (lr2),dh (lr2)
     $             ,dph(lr2),jph(lr2),zh (lr2),wh (lr2)  ! Pressure GLL
     $             ,bgl(lr2),zgl(lr2),dgl(lr2),jgl(lr2)  ! Pressure GL 
      real ah,bh,ch,dh,dph,jph,zh,wh,bgl,zgl,dgl,jgl
c     
      parameter (l3=lx1*(lx1+1)*(lx1+2)/3)
      parameter (l2=lx1*(lx1+1)/2)
      common /hata/ dd(l3),zp(l2),ww(l2)   ! Aggregate arrays
# 1639 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1639 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real w(lx1+2)
      integer nf,nc,nr
      integer nx,ny,nz
      
      integer mgn2(10)
      save    mgn2
      data    mgn2 / 1, 2, 2, 2, 2, 3, 3, 5, 5, 5/
c     data    mgn2 / 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
      
c     if (param(82).eq.0) param(82)=2  ! nek default
c     if (np.eq.1)        param(82)=2  ! single proc. too slow
      p82 = 2                          ! potentially variable nxc
      mg_lmax = 3
c     mg_lmax = 4
      if (lx1.eq.4) mg_lmax = 2
c     if (param(79).ne.0) mg_lmax = param(79)
      mgnx1    = p82-1 !1
      mg_nx(1) = mgnx1
      mg_ny(1) = mgnx1
      mg_nz(1) = mgnx1
      if (.not.if3d) mg_nz(1) = 0 
      
      mgnx2 = 2*(lx2/4) + 1
      if (lx1.eq.5)  mgnx2 = 3
c     if (lx1.eq.6)  mgnx2 = 3
      if (lx1.le.10) mgnx2 = mgn2(nx1)
      if (lx1.eq.8)  mgnx2 = 4
      if (lx1.eq.8)  mgnx2 = 3
      
c     mgnx2 = min(3,mgnx2)  
      
      mg_nx(2) = mgnx2
      mg_ny(2) = mgnx2
      mg_nz(2) = mgnx2
      if (.not.if3d) mg_nz(2) = 0 
      
      mg_nx(3) = mgnx2+1
      mg_ny(3) = mgnx2+1
      mg_nz(3) = mgnx2+1
      if (.not.if3d) mg_nz(3) = 0 
      
      mg_nx(mg_lmax) = lx1-1
      mg_ny(mg_lmax) = ly1-1
      mg_nz(mg_lmax) = lz1-1
      
      if (nid.eq.0) write(*,*) 'mg_nx:',(mg_nx(i),i=1,mg_lmax)
      if (nid.eq.0) write(*,*) 'mg_ny:',(mg_ny(i),i=1,mg_lmax)
      if (nid.eq.0) write(*,*) 'mg_nz:',(mg_nz(i),i=1,mg_lmax)
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_index_0 ! initialize index sets

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1693 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1693 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1694 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1694 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      n = lmgn*(lmgs+1)
      
      call izero( mg_rstr_wt_index      , n )
      call izero( mg_mask_index         , n )
      call izero( mg_solve_index        , n )
      call izero( mg_fast_s_index       , n )
      call izero( mg_fast_d_index       , n )
      call izero( mg_schwarz_wt_index   , n )
      
      return
      end
c----------------------------------------------------------------------
      subroutine outfldn (x,n,txt10,ichk) ! writes into unit=40+ifiled

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1709 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1709 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1710 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1710 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real x(n,n,1,lelt)
      character*10 txt10
c     
      integer idum,e
      save    idum
      data    idum /3/
      if (idum.lt.0)   return
      m = 40 + ifield                 ! unit #
c     
C     
      mtot = n*n*nelv
      if (n.gt.7.or.nelv.gt.16) return
      xmin = glmin(x,mtot)
      xmax = glmax(x,mtot)
c     
      rnel = nelv
      snel = sqrt(rnel)+.1
      ne   = snel
      ne1  = nelv-ne+1
      do ie=ne1,1,-ne
         l=ie-1
         do k=1,1
            if (ie.eq.ne1) write(m,116) txt10,k,ie,xmin,xmax,ichk,time
            write(m,117) 
            do j=n,1,-1
              if (n.eq.2) write(m,102) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.3) write(m,103) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.4) write(m,104) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.5) write(m,105) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.6) write(m,106) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.7) write(m,107) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.8) write(m,108) ((x(i,j,k,e+l),i=1,n),e=1,ne)
            enddo
         enddo
      enddo
      
C     
  102 FORMAT(4(2f9.5,2x))
  103 FORMAT(4(3f9.5,2x))
  104 FORMAT(4(4f7.3,2x))
  105 FORMAT(5f9.5,10x,5f9.5)
  106 FORMAT(6f9.5,5x,6f9.5)
  107 FORMAT(7f8.4,5x,7f8.4)
  108 FORMAT(8f8.4,4x,8f8.4)
c     
  116 FORMAT(  /,5X,'     ^              ',/,
     $    5X,'   Y |              ',/,
     $    5X,'     |              ',A10,/,
     $    5X,'     +---->         ','Plane = ',I2,'/',I2,2x,2e12.4,/,
     $    5X,'       X            ','Step  =',I9,f15.5)
  117 FORMAT(' ')
c     
c     if (ichk.eq.1.and.idum.gt.0) call checkit(idum)
      return
      end
c-----------------------------------------------------------------------
      subroutine outfldn0 (x,n,txt10,ichk)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1768 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1768 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1769 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1769 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real x(n,n,1,lelt)
      character*10 txt10
c     
      integer idum,e
      save idum
      data idum /3/
      if (idum.lt.0) return
c     
C     
      mtot = n*n*nelv
      if (n.gt.7.or.nelv.gt.16) return
      xmin = glmin(x,mtot)
      xmax = glmax(x,mtot)
c     
      rnel = nelv
      snel = sqrt(rnel)+.1
      ne   = snel
      ne1  = nelv-ne+1
      do ie=ne1,1,-ne
         l=ie-1
         do k=1,1
            if (ie.eq.ne1) write(6,116) txt10,k,ie,xmin,xmax,ichk,time
            write(6,117) 
            do j=n,1,-1
              if (n.eq.2) write(6,102) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.3) write(6,103) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.4) write(6,104) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.5) write(6,105) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.6) write(6,106) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.7) write(6,107) ((x(i,j,k,e+l),i=1,n),e=1,ne)
              if (n.eq.8) write(6,108) ((x(i,j,k,e+l),i=1,n),e=1,ne)
            enddo
         enddo
      enddo
      
C     
  102 FORMAT(4(2f9.5,2x))
  103 FORMAT(4(3f9.5,2x))
  104 FORMAT(4(4f7.3,2x))
  105 FORMAT(5f9.5,10x,5f9.5)
  106 FORMAT(6f9.5,5x,6f9.5)
  107 FORMAT(7f8.4,5x,7f8.4)
  108 FORMAT(8f8.4,4x,8f8.4)
c     
  116 FORMAT(  /,5X,'     ^              ',/,
     $    5X,'   Y |              ',/,
     $    5X,'     |              ',A10,/,
     $    5X,'     +---->         ','Plane = ',I2,'/',I2,2x,2e12.4,/,
     $    5X,'       X            ','Step  =',I9,f15.5)
  117 FORMAT(' ')
c     
c     if (ichk.eq.1.and.idum.gt.0) call checkit(idum)
      return
      end
c-----------------------------------------------------------------------
      subroutine outflda (x,n,txt10,ichk) ! writes into unit=p130+ifiled

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1826 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1826 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1827 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1827 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1828 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1828 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real x(1)
      character*10 txt10                  ! note: n is not used
c     parameter (eps=1.e-7)
C     
      p130 = param(130)
      eps  = param(131)
      if (p130.le.0)    return
      m    = 6
      if (p130.gt.9)  m = p130 + ifield
      
      ntot = nx1*ny1*nz1*nelfld(ifield)
      
      xmin = glmin(x,ntot)
      xmax = glmax(x,ntot)
      xavg = glsum(x,ntot)/ntot
      
      if (abs(xavg).lt.eps) xavg = 0.     ! truncation
      
      if (nid.eq.0) write(m,10) txt10,ichk,ntot,xavg,xmin,xmax
      
   10 format(3X,a10,2i8,' pts, avg,min,max = ',1p3g14.6)
c     
      return
      end
c-----------------------------------------------------------------------
      subroutine outfldan(x,n,txt10,ichk) ! writes x(1:n) into unit=p130

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1855 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1855 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1856 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1856 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1857 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1857 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real x(1)
      character*10 txt10
c     parameter (eps=1.e-7)
C     
      p130 = param(130)
      eps  = param(131)
      if (p130.le.0)    return
      m    = 6
      if (p130.gt.9)  m = p130 + ifield
      
      ntot = n
      
      xmin = glmin(x,ntot)
      xmax = glmax(x,ntot)
      xavg = glsum(x,ntot)/ntot
      
      if (abs(xavg).lt.eps) xavg = 0.     ! truncation
      
      if (nid.eq.0) write(m,10) txt10,ichk,ntot,xavg,xmin,xmax
      
   10 format(3X,a10,2i8,' pts, avg,min,max = ',1p3g11.3)
c  10 format(3X,a10,2i8,' pts, avg,min,max = ',1p3g14.6)
c     
      return
      end
c-----------------------------------------------------------------------
      subroutine h1mg_solve(z,rhs,if_hybrid)  !  Solve preconditioner: M
      real z(1),rhs(1)
      
c     Assumes that preprocessing has been completed via h1mg_setup()
      
      

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1890 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1890 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1891 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1891 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 1892 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1892 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 1893 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1893 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 1894 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1894 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 1895 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1895 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1896 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1896 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 1897 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1897 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 1898 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1898 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      common /scrhi/ h2inv (lx1,ly1,lz1,lelv)
      common /scrvh/ h1    (lx1,ly1,lz1,lelv),
     $               h2    (lx1,ly1,lz1,lelv)
      parameter (lt=lx1*ly1*lz1*lelt)
      common /scrmg/ e(2*lt),w(lt),r(lt)
      integer p_msk,p_b
      logical if_hybrid
      
c     if_hybrid = .true.    ! Control this from gmres, according
c     if_hybrid = .false.   ! to convergence efficiency
      
      nel   = nelfld(ifield)
      
      op    =  1.                                     ! Coefficients for
      om    = -1.
      sigma =  1.
      if (if_hybrid) sigma = 2./3.
      
      l     = mg_h1_lmax
      n     = mg_h1_n(l,mg_fld)
      is    = 1                                       ! solve index
      
      call h1mg_schwarz(z,rhs,sigma,l)                ! z := sigma W M  
                                                      !               Sc
      call copy(r,rhs,n)                              ! r  := rhs
      if (if_hybrid) call h1mg_axm(r,z,op,om,l,w)     ! r  := rhs - A z
                                                      !  l
      
      do l = mg_h1_lmax-1,2,-1                        ! DOWNWARD Leg of 
         is = is + n
         n  = mg_h1_n(l,mg_fld)
                                                      !          T
         call h1mg_rstr(r,l,.true.)                   ! r   :=  J r
                                                      !  l         l+1
!        OVERLAPPING Schwarz exchange and solve:
         call h1mg_schwarz(e(is),r,sigma,l)           ! e := sigma W M  
                                                      !  l            Sc
      
         if(if_hybrid)call h1mg_axm(r,e(is),op,om,l,w)! r  := r - A e
                                                      !  l           l
      enddo
      is = is+n
                                                      !         T
      call h1mg_rstr(r,1,.false.)                     ! r  :=  J  r
                                                      !  l         l+1
      p_msk = p_mg_msk(l,mg_fld)
      call h1mg_mask(r,mg_imask(p_msk),nel)           !        -1
      call hsmg_coarse_solve ( e(is) , r )            ! e  := A   r
      call h1mg_mask(e(is),mg_imask(p_msk),nel)       !  1     1   1
      
c     nx = mg_nh(1)
c     call outnxfld (e(is),nx,nelv,'ecrsb4',is)
c     call h1mg_mask(e(is),mg_imask(p_msk),nel)       !  1     1   1
c     call outnxfld (e(is),nx,nelv,'ecrsaf',is)
c     call exitt
      
      do l = 2,mg_h1_lmax-1                           ! UNWIND.  No smoo
         im = is
         is = is - n
         n  = mg_h1_n(l,mg_fld)
         call hsmg_intp (w,e(im),l-1)                 ! w   :=  J e
         i1=is-1                                      !            l-1
         do i=1,n
            e(i1+i) = e(i1+i) + w(i)                  ! e   :=  e  + w
         enddo                                        !  l       l
      enddo
      
      l  = mg_h1_lmax
      n  = mg_h1_n(l,mg_fld)
      im = is  ! solve index
      call hsmg_intp(w,e(im),l-1)                     ! w   :=  J e
      do i = 1,n                                      !            l-1
         z(i) = z(i) + w(i)                           ! z := z + w
      enddo
      
      call dsavg(z) ! Emergency hack --- to ensure continuous z!
      
      return
      end
c-----------------------------------------------------------------------
      subroutine h1mg_axm(w,p,aw,ap,l,wk)
c     
c     w  := aw*w + ap*H*p, level l, with mask and dssum
c     
c     Hu := div. h1 grad u + h2 u
c     
c        ~= h1 A u + h2 B u
c     
c     Here, we assume that pointers into g() and h1() and h2() have
c     been established
c     

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 1991 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1991 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 1992 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1992 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 1993 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 1993 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real w(1),p(1),wk(1)
      
      integer p_h1,p_h2,p_g,p_b,p_msk
      logical ifh2
      
      p_h1  = p_mg_h1  (l,mg_fld)
      p_h2  = p_mg_h2  (l,mg_fld)
      p_g   = p_mg_g   (l,mg_fld)
      p_b   = p_mg_b   (l,mg_fld)
      p_msk = p_mg_msk (l,mg_fld)
      
      if (p_h1 .eq.0) call mg_set_h1  (p_h1 ,l)
      if (p_h2 .eq.0) call mg_set_h2  (p_h2 ,l)
      if (p_g  .eq.0) call mg_set_gb  (p_g,p_b,l)
      if (p_msk.eq.0) call mg_set_msk (p_msk,l)
      
      ifh2 = .true.
      if (p_h2.eq.0) ifh2 = .false.  ! Need a much better mech.
      ifh2 = .false.
      
      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nhz(l)
      ng = 3*ndim-3
      
      
      call h1mg_axml (wk,p
     $               ,mg_h1(p_h1),mg_h2(p_h2),nx,ny,nz,nelfld(ifield)
     $               ,mg_g (p_g) , ng ,mg_b(p_b), mg_imask(p_msk),ifh2)
      
      
      call hsmg_dssum (wk,l)
      
      n = nx*ny*nz*nelfld(ifield)
      call add2sxy    (w,aw,wk,ap,n)
      
      return
      end
c-----------------------------------------------------------------------
      subroutine h1mg_axml
     $  (w,p,h1,h2,nx,ny,nz,nel,g,ng,b,mask,ifh2)
c     
c     w  := aw*w + ap*H*p, level l, with mask and dssum
c     
c     Hu := div. h1 grad u + h2 u
c     
c        ~= h1 A u + h2 B u
c     
      

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2044 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2044 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOTAL" 1

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DXYZ" 1
C     
C     Elemental derivative operators
C     
# 4
      COMMON /DXYZ/ DXM1(LX1,LX1),  DXM12(LX2,LX1)
     $             ,DYM1(LY1,LY1),  DYM12(LY2,LY1)
     $             ,DZM1(LZ1,LZ1),  DZM12(LZ2,LZ1)
     $             ,DXTM1(LX1,LX1), DXTM12(LX1,LX2)
     $             ,DYTM1(LY1,LY1), DYTM12(LY1,LY2)
     $             ,DZTM1(LZ1,LZ1), DZTM12(LZ1,LZ2)
     $             ,DXM3(LX3,LX3),  DXTM3(LX3,LX3)
     $             ,DYM3(LY3,LY3),  DYTM3(LY3,LY3)
     $             ,DZM3(LZ3,LZ3),  DZTM3(LZ3,LZ3)
     $             ,DCM1(LY1,LY1),  DCTM1(LY1,LY1)
     $             ,DCM3(LY3,LY3),  DCTM3(LY3,LY3)
     $             ,DCM12(LY2,LY1), DCTM12(LY1,LY2)
     $             ,DAM1(LY1,LY1),  DATM1(LY1,LY1)
     $             ,DAM12(LY2,LY1), DATM12(LY1,LY2)
     $             ,DAM3(LY3,LY3),  DATM3(LY3,LY3)
      
# 2 "TOTAL" 2
# 2 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DEALIAS" 1
# 1
      common /solnd/  vxd(lxd,lyd,lzd,lelv)
     $             ,  vyd(lxd,lyd,lzd,lelv)
     $             ,  vzd(lxd,lyd,lzd,lelv)
      common /interpd/ imd1(lx1,lxd),imd1t(lxd,lx1)
     $               , im1d(lxd,lx1),im1dt(lx1,lxd)
     $               , pmd1(lx1,lxd),pmd1t(lxd,lx1)
c     common /dedim/ nxd,nyd,nzd
      real imd1,imd1t,im1d,im1dt
c     
# 3 "TOTAL" 2
# 3 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/EIGEN" 1
C     
C     Eigenvalues
C     
# 4
      COMMON /EIGVAL/ EIGAA, EIGAS, EIGAST, EIGAE
     $               ,EIGGA, EIGGS, EIGGST, EIGGE
      COMMON /IFEIG / IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      LOGICAL         IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      
# 4 "TOTAL" 2
# 4 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 5 "TOTAL" 2
# 5 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 6 "TOTAL" 2
# 6 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/IXYZ" 1
C     
C     Interpolation operators
C     
# 4
      COMMON /IXYZ/ IXM12 (LX2,LX1),  IXM21 (LX1,LX2)
     $             ,IYM12 (LY2,LY1),  IYM21 (LY1,LY2)
     $             ,IZM12 (LZ2,LZ1),  IZM21 (LZ1,LZ2)
     $             ,IXTM12(LX1,LX2),  IXTM21(LX2,LX1)
     $             ,IYTM12(LY1,LY2),  IYTM21(LY2,LY1)
     $             ,IZTM12(LZ1,LZ2),  IZTM21(LZ2,LZ1)
     $             ,IXM13 (LX3,LX1),  IXM31 (LX1,LX3)
     $             ,IYM13 (LY3,LY1),  IYM31 (LY1,LY3)
     $             ,IZM13 (LZ3,LZ1),  IZM31 (LZ1,LZ3)
     $             ,IXTM13(LX1,LX3),  IXTM31(LX3,LX1)
     $             ,IYTM13(LY1,LY3),  IYTM31(LY3,LY1)
     $             ,IZTM13(LZ1,LZ3),  IZTM31(LZ3,LZ1)
      COMMON /IXYZA/
     $              IAM12 (LY2,LY1),  IAM21 (LY1,LY2)
     $             ,IATM12(LY1,LY2),  IATM21(LY2,LY1)
     $             ,IAM13 (LY3,LY1),  IAM31 (LY1,LY3)
     $             ,IATM13(LY1,LY3),  IATM31(LY3,LY1)
     $             ,ICM12 (LY2,LY1),  ICM21 (LY1,LY2)
     $             ,ICTM12(LY1,LY2),  ICTM21(LY2,LY1)
     $             ,ICM13 (LY3,LY1),  ICM31 (LY1,LY3)
     $             ,ICTM13(LY1,LY3),  ICTM31(LY3,LY1)
     $             ,IAJL1 (LY1,LY1),  IATJL1(LY1,LY1)
     $             ,IAJL2 (LY2,LY2),  IATJL2(LY2,LY2)
     $             ,IALJ3 (LY3,LY3),  IATLJ3(LY3,LY3)
     $             ,IALJ1 (LY1,LY1),  IATLJ1(LY1,LY1)
C     
      REAL   IXM12,IYM12,IZM12,IXM21,IYM21,IZM21
      REAL   IXTM12,IYTM12,IZTM12,IXTM21,IYTM21,IZTM21
      REAL   IXM13,IYM13,IZM13,IXM31,IYM31,IZM31
      REAL   IXTM13,IYTM13,IZTM13,IXTM31,IYTM31,IZTM31
      REAL   IAM12,IAM21,IATM12,IATM21,IAM13,IAM31,IATM13,IATM31
      REAL   ICM12,ICM21,ICTM12,ICTM21,ICM13,ICM31,ICTM13,ICTM31
      REAL   IAJL1,IATJL1,IAJL2,IATJL2,IALJ3,IATLJ3,IALJ1,IATLJ1
# 7 "TOTAL" 2
# 7 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 8 "TOTAL" 2
# 8 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MVGEOM" 1
C     
C     Moving mesh data
C     
# 4
      COMMON /WSOL/   WX    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WY    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WZ    (LX1M,LY1M,LZ1M,LELT)
      COMMON /WLAG/   WXLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WYLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WZLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
      COMMON /WMSU/   W1MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W2MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W3MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   WMULT (LX1M,LY1M,LZ1M,LELT)
      COMMON /EIGVEC/ EV1   (LX1M,LY1M,LZ1M,LELV)
     $              , EV2   (LX1M,LY1M,LZ1M,LELV)
     $              , EV3   (LX1M,LY1M,LZ1M,LELV)
# 9 "TOTAL" 2
# 9 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 10 "TOTAL" 2
# 10 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 11 "TOTAL" 2
# 11 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/STEADY" 1
# 1
      COMMON /SSPAR1/ TAUSS(LDIMT1) , TXNEXT(LDIMT1)
      COMMON /SSPAR2/ NSSKIP
      COMMON /SSPAR3/ IFSKIP, IFMODP, IFSSVT, IFSTST(LDIMT1)
     $              ,                 IFEXVT, IFEXTR(LDIMT1)
      LOGICAL         IFSKIP, IFMODP, IFSSVT, IFSTST
     $              ,                 IFEXVT, IFEXTR
      COMMON /SSNORM/ DVNNH1, DVNNSM, DVNNL2, DVNNL8
     $              , DVDFH1, DVDFSM, DVDFL2, DVDFL8
     $              , DVPRH1, DVPRSM, DVPRL2, DVPRL8
# 12 "TOTAL" 2
# 12 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOPOL" 1
C     
C     Arrays for direct stiffness summation
C     
# 4
      COMMON /CFACES/ NOMLIS(2,3),NMLINV(6),GROUP(6),SKPDAT(6,6)
     $               ,EFACE(6),EFACE1(6)
c     
      INTEGER NOMLIS,NMLINV,GROUP,SKPDAT,EFACE,EFACE1
      COMMON /CEDGES/ ESKIP(-12:12,3),NEDG(3)    ,NCMP
     $               ,IXCN(8),NOFFST(3,0:LDIMT1)
     $               ,MAXMLT,NSPMAX(0:LDIMT1)
     $               ,NGSPCN(0:LDIMT1),NGSPED(3,0:LDIMT1)
     $               ,NUMSCN(LELT,0:LDIMT1),NUMSED(LELT,0:LDIMT1)
     $               ,GCNNUM( 8,LELT,0:LDIMT1),LCNNUM( 8,LELT,0:LDIMT1)
     $               ,GEDNUM(12,LELT,0:LDIMT1),LEDNUM(12,LELT,0:LDIMT1)
     $               ,GEDTYP(12,LELT,0:LDIMT1)
     $               ,NGCOMM(2,0:LDIMT1)
      INTEGER ESKIP,NEDG,IXCN,MAXMLT,NSPMAX,NOFFST,NGSPCN,NGSPED
     $       ,NUMSCN,NUMSED,GCNNUM,LCNNUM,GEDNUM,LEDNUM,GEDTYP
     $       ,NGCOMM
      COMMON /EDGES/ IEDGE(20),IEDGEF(2,4,6,0:1)
     $              ,ICEDG(3,16),IEDGFC(4,6),ICFACE(4,10)
     $              ,INDX(8),INVEDG(27)
      
# 13 "TOTAL" 2
# 13 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 14 "TOTAL" 2
# 14 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TURBO" 1
C     
C       Common block for turbulence model
C     
# 4
      COMMON /TURBR/ VTURB (LX1M,LY1M,LZ1M,LELV)
     $             , TURBL (LX1M,LY1M,LZ1M,LELV)
     $             , UWALL (LX1M,LZ1M,6,LELV)
     $             , ZWALL (LX1M,LZ1M,6,LELV)
     $             , TWX   (LX1M,LZ1M,6,LELV)
     $             , TWY   (LX1M,LZ1M,6,LELV)
     $             , TWZ   (LX1M,LZ1M,6,LELV)
      COMMON /TURBC/ CMU,CMT,SGK,SGE,CE1,CE2,VKC,BTA,SGT
     $             , BETA1,BETA2
     $             , CMI,SKI,SEI,VKI,BTI,STI
     $             , ZPLDAT,ZPUDAT,ZPVDAT,TLMAX,TLIMUL
      COMMON /TURBI/ IFLDK,IFLDTK,IFLDE,IFLDTE
      COMMON /TURBL/ IFSWALL,IFTWSH(6,LELV),IFCWUZ
C     
      
      LOGICAL IFSWALL,IFTWSH,IFCWUZ
# 15 "TOTAL" 2
# 15 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/ESOLV" 1
# 1
      common /econst/ iesolv
      common /efastm/ ifalgn(lelv), ifrsxy(lelv)
      logical         ifalgn, ifrsxy
      common /eouter/ volel(lelv) 
# 16 "TOTAL" 2
# 16 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZ" 1
C     
C     Gauss-Labotto and Gauss points
C     
# 4
      COMMON /GAUSS/ ZGM1(LX1,3), ZGM2(LX2,3), ZGM3(LX3,3)
     $              ,ZAM1(LX1)  , ZAM2(LX2)  , ZAM3(LX3)
C     
C    Weights
C     
      COMMON /WXYZ/ WXM1(LX1), WYM1(LY1), WZM1(LZ1), W3M1(LX1,LY1,LZ1)
     $             ,WXM2(LX2), WYM2(LY2), WZM2(LZ2), W3M2(LX2,LY2,LZ2)
     $             ,WXM3(LX3), WYM3(LY3), WZM3(LZ3), W3M3(LX3,LY3,LZ3)
     $             ,WAM1(LY1), WAM2(LY2), WAM3(LY3)
     $             ,W2AM1(LX1,LY1), W2CM1(LX1,LY1)
     $             ,W2AM2(LX2,LY2), W2CM2(LX2,LY2)
     $             ,W2AM3(LX3,LY3), W2CM3(LX3,LY3)
# 17 "TOTAL" 2
# 17 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZF" 1
c     
c Points (z) and weights (w) on velocity, pressure
c     
c     zgl -- velocity points on Gauss-Lobatto points i = 1,...nx
c     zgp -- pressure points on Gauss         points i = 1,...nxp (nxp =
c     
c     parameter (lxm = lx1)
# 8
      parameter (lxq = lx2)
c     
      common /wz1/   zgl(lx1),wgl(lx1)
     $           ,   zgp(lx1),wgp(lxq)
c     
c     Tensor- (outer-) product of 1D weights   (for volumetric integrati
c     
      common /wz2/  wgl1(lx1*lx1),wgl2(lxq*lxq)
     $           ,  wgli(lx1*lx1)
c     
c     
c    Frequently used derivative matrices:
c     
c    D1, D1t   ---  differentiate on mesh 1 (velocity mesh)
c    D2, D2t   ---  differentiate on mesh 2 (pressure mesh)
c     
c    DXd,DXdt  ---  differentiate from velocity mesh ONTO dealiased mesh
c                   (currently the same as D1 and D1t...)
c     
c     
      common /deriv/  d1    (lx1*lx1) , d1t    (lx1*lx1)
     $             ,  d2    (lx1*lx1) , b2p    (lx1*lx1)
     $             ,  B1iA1 (lx1*lx1) , B1iA1t (lx1*lx1)
     $             ,  da    (lx1*lx1) , dat    (lx1*lx1)
     $             ,  iggl  (lx1*lxq) , igglt  (lx1*lxq)
     $             ,  dglg  (lx1*lxq) , dglgt  (lx1*lxq)
     $             ,  wglg  (lx1*lxq) , wglgt  (lx1*lxq)
      real ixd,ixdt,iggl,igglt
c     
# 18 "TOTAL" 2
# 18 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DSSUM" 1
# 1
      parameter (lds=lx1*ly1*lz1*lelt)
      common /newdss/ ids_lgl1(-1:lds),ids_lgl2(-1:lds),ids_ptr(lds)
# 2045 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2045 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2046 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2046 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real w (nx*ny*nz,nel), p (nx*ny*nz,nel)
     $   , h1(nx*ny*nz,nel), h2(nx*ny*nz,nel)
     $   , b (nx*ny*nz,nel), g (ng*nx*ny*nz,nel)
      integer mask(1)
      
      logical ifh2
      
      parameter (lxyz=lx1*ly1*lz1)
      common /ctmp0/ ur(lxyz),us(lxyz),ut(lxyz)
      
      integer e
      
      do e=1,nel
      
         call axe(w(1,e),p(1,e),h1(1,e),h2(1,e),g(1,e),ng,b(1,e)
     $            ,nx,ny,nz,ur,us,ut,ifh2,ifrzer(e),e)
      
         im = mask(e)
         call mg_mask_e(w,mask(im)) ! Zero out Dirichlet conditions
      
      enddo
      
      return
      end
c-----------------------------------------------------------------------
      subroutine h1mg_mask(w,mask,nel)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2074 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2074 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real    w   (1)
      integer mask(1)        ! Pointer to Dirichlet BCs
      integer e
      
      do e=1,nel
         im = mask(e)
         call mg_mask_e(w,mask(im)) ! Zero out Dirichlet conditions
      enddo
      
      return
      end
c----------------------------------------------------------------------
      subroutine mg_mask_e(w,mask) ! Zero out Dirichlet conditions

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2089 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2089 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real w(1)
      integer mask(0:1)
      
      n=mask(0)
      do i=1,n
c        write(6,*) i,mask(i),n,' MG_MASK'
         w(mask(i)) = 0.
      enddo
      
      return
      end
c-----------------------------------------------------------------------
      subroutine axe
     $     (w,p,h1,h2,g,ng,b,nx,ny,nz,ur,us,ut,ifh2,ifrz,e)
      

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2105 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2105 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2106 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2106 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      logical ifh2,ifrz
      
      real w (nx*ny*nz), p (nx*ny*nz)
     $   , h1(nx*ny*nz), h2(nx*ny*nz)
     $   , b (nx*ny*nz), g (ng,nx*ny*nz)
     $   , ur(nx*ny*nz), us(nx*ny*nz), ut(nx*ny*nz)
      integer e
      
      nxyz = nx*ny*nz
      
      call gradl_rst(ur,us,ut,p,nx,if3d)
c     if (e.eq.1) then
c        call outmat(p ,nx,ny,'ur A p',e)
c        call outmat(ur,nx,ny,'ur A r',e)
c        call outmat(us,nx,ny,'ur A s',e)
c     endif
      
      if (if3d) then
         do i=1,nxyz
            wr = g(1,i)*ur(i) + g(4,i)*us(i) + g(5,i)*ut(i)
            ws = g(4,i)*ur(i) + g(2,i)*us(i) + g(6,i)*ut(i)
            wt = g(5,i)*ur(i) + g(6,i)*us(i) + g(3,i)*ut(i)
            ur(i) = wr*h1(i)
            us(i) = ws*h1(i)
            ut(i) = wt*h1(i)
         enddo
      elseif (ifaxis) then
         call exitti('Blame Paul for no gradl_rst support yet$',nx)
      else
         do i=1,nxyz
            wr = g(1,i)*ur(i) + g(3,i)*us(i)
            ws = g(3,i)*ur(i) + g(2,i)*us(i)
c           write(6,3) i,ur(i),wr,g(1,i)/b(i),b(i)
c 3         format(i5,1p4e12.4,' wrws')
            ur(i) = wr*h1(i)
            us(i) = ws*h1(i)
         enddo
      endif
      
      call gradl_rst_t(w,ur,us,ut,nx,if3d)
      
c     if (e.eq.1) then
c        call outmat(w ,nx,ny,'ur B w',e)
c        call outmat(ur,nx,ny,'ur B r',e)
c        call outmat(us,nx,ny,'ur B s',e)
c     endif
      
      if (ifh2) then
        do i=1,nxyz
          w(i)=w(i)+h2(i)*b(i)*p(i)
        enddo
      endif
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_tnsr1(v,nv,nu,A,At)
c     
c     v = [A (x) A] u      or
c     v = [A (x) A (x) A] u 
c     
      integer nv,nu
      real v(1),A(1),At(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2170 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2170 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2171 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2171 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      if (.not. if3d) then
         call hsmg_tnsr1_2d(v,nv,nu,A,At)
      else
         call hsmg_tnsr1_3d(v,nv,nu,A,At,At)
      endif
      return
      end
c-------------------------------------------------------T--------------
      subroutine hsmg_tnsr1_2d(v,nv,nu,A,Bt) ! u = A u B
      integer nv,nu
      real v(1),A(1),Bt(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2183 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2183 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      common /hsmgw/ work(lx1*lx1)
      integer e
      
      nv2 = nv*nv
      nu2 = nu*nu
      
      if (nv.le.nu) then
         iv=1
         iu=1
         do e=1,nelv
            call mxm(A,nv,v(iu),nu,work,nu)
            call mxm(work,nv,Bt,nu,v(iv),nv)
            iv = iv + nv2
            iu = iu + nu2
         enddo
      else
         do e=nelv,1,-1
            iu=1+nu2*(e-1)
            iv=1+nv2*(e-1)
            call mxm(A,nv,v(iu),nu,work,nu)
            call mxm(work,nv,Bt,nu,v(iv),nv)
         enddo
      endif
      
      return
      end
c----------------------------------------------------------------------
      subroutine hsmg_tnsr1_3d(v,nv,nu,A,Bt,Ct) ! v = [C (x) B (x) A] u
      integer nv,nu
      real v(1),A(1),Bt(1),Ct(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2214 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2214 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter (lwk=(lx1+2)*(ly1+2)*(lz1+2))
      common /hsmgw/ work(0:lwk-1),work2(0:lwk-1)
      integer e,e0,ee,es
      
      e0=1
      es=1
      ee=nelv
      
      if (nv.gt.nu) then
         e0=nelv
         es=-1
         ee=1
      endif
      
      nu3 = nu**3
      nv3 = nv**3
      
      do e=e0,ee,es
         iu = 1 + (e-1)*nu3
         iv = 1 + (e-1)*nv3
         call mxm(A,nv,v(iu),nu,work,nu*nu)
         do i=0,nu-1
            call mxm(work(nv*nu*i),nv,Bt,nu,work2(nv*nv*i),nv)
         enddo
         call mxm(work2,nv*nv,Ct,nu,v(iv),nv)
      enddo
      
      return
      end
c------------------------------------------   T  -----------------------
      subroutine h1mg_rstr(r,l,ifdssum) ! r =J r,   l is coarse level

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2246 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2246 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2247 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2247 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      logical ifdssum
      
      real r(1)
      integer l
      
      call hsmg_do_wt(r,mg_rstr_wt(mg_rstr_wt_index(l+1,mg_fld))
     $                     ,mg_nh(l+1),mg_nh(l+1),mg_nhz(l+1))
      
      call hsmg_tnsr1(r,mg_nh(l),mg_nh(l+1),mg_jht(1,l),mg_jh(1,l))
      
      if (ifdssum) call hsmg_dssum(r,l)
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup()

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2264 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2264 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOTAL" 1

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DXYZ" 1
C     
C     Elemental derivative operators
C     
# 4
      COMMON /DXYZ/ DXM1(LX1,LX1),  DXM12(LX2,LX1)
     $             ,DYM1(LY1,LY1),  DYM12(LY2,LY1)
     $             ,DZM1(LZ1,LZ1),  DZM12(LZ2,LZ1)
     $             ,DXTM1(LX1,LX1), DXTM12(LX1,LX2)
     $             ,DYTM1(LY1,LY1), DYTM12(LY1,LY2)
     $             ,DZTM1(LZ1,LZ1), DZTM12(LZ1,LZ2)
     $             ,DXM3(LX3,LX3),  DXTM3(LX3,LX3)
     $             ,DYM3(LY3,LY3),  DYTM3(LY3,LY3)
     $             ,DZM3(LZ3,LZ3),  DZTM3(LZ3,LZ3)
     $             ,DCM1(LY1,LY1),  DCTM1(LY1,LY1)
     $             ,DCM3(LY3,LY3),  DCTM3(LY3,LY3)
     $             ,DCM12(LY2,LY1), DCTM12(LY1,LY2)
     $             ,DAM1(LY1,LY1),  DATM1(LY1,LY1)
     $             ,DAM12(LY2,LY1), DATM12(LY1,LY2)
     $             ,DAM3(LY3,LY3),  DATM3(LY3,LY3)
      
# 2 "TOTAL" 2
# 2 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DEALIAS" 1
# 1
      common /solnd/  vxd(lxd,lyd,lzd,lelv)
     $             ,  vyd(lxd,lyd,lzd,lelv)
     $             ,  vzd(lxd,lyd,lzd,lelv)
      common /interpd/ imd1(lx1,lxd),imd1t(lxd,lx1)
     $               , im1d(lxd,lx1),im1dt(lx1,lxd)
     $               , pmd1(lx1,lxd),pmd1t(lxd,lx1)
c     common /dedim/ nxd,nyd,nzd
      real imd1,imd1t,im1d,im1dt
c     
# 3 "TOTAL" 2
# 3 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/EIGEN" 1
C     
C     Eigenvalues
C     
# 4
      COMMON /EIGVAL/ EIGAA, EIGAS, EIGAST, EIGAE
     $               ,EIGGA, EIGGS, EIGGST, EIGGE
      COMMON /IFEIG / IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      LOGICAL         IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      
# 4 "TOTAL" 2
# 4 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 5 "TOTAL" 2
# 5 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 6 "TOTAL" 2
# 6 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/IXYZ" 1
C     
C     Interpolation operators
C     
# 4
      COMMON /IXYZ/ IXM12 (LX2,LX1),  IXM21 (LX1,LX2)
     $             ,IYM12 (LY2,LY1),  IYM21 (LY1,LY2)
     $             ,IZM12 (LZ2,LZ1),  IZM21 (LZ1,LZ2)
     $             ,IXTM12(LX1,LX2),  IXTM21(LX2,LX1)
     $             ,IYTM12(LY1,LY2),  IYTM21(LY2,LY1)
     $             ,IZTM12(LZ1,LZ2),  IZTM21(LZ2,LZ1)
     $             ,IXM13 (LX3,LX1),  IXM31 (LX1,LX3)
     $             ,IYM13 (LY3,LY1),  IYM31 (LY1,LY3)
     $             ,IZM13 (LZ3,LZ1),  IZM31 (LZ1,LZ3)
     $             ,IXTM13(LX1,LX3),  IXTM31(LX3,LX1)
     $             ,IYTM13(LY1,LY3),  IYTM31(LY3,LY1)
     $             ,IZTM13(LZ1,LZ3),  IZTM31(LZ3,LZ1)
      COMMON /IXYZA/
     $              IAM12 (LY2,LY1),  IAM21 (LY1,LY2)
     $             ,IATM12(LY1,LY2),  IATM21(LY2,LY1)
     $             ,IAM13 (LY3,LY1),  IAM31 (LY1,LY3)
     $             ,IATM13(LY1,LY3),  IATM31(LY3,LY1)
     $             ,ICM12 (LY2,LY1),  ICM21 (LY1,LY2)
     $             ,ICTM12(LY1,LY2),  ICTM21(LY2,LY1)
     $             ,ICM13 (LY3,LY1),  ICM31 (LY1,LY3)
     $             ,ICTM13(LY1,LY3),  ICTM31(LY3,LY1)
     $             ,IAJL1 (LY1,LY1),  IATJL1(LY1,LY1)
     $             ,IAJL2 (LY2,LY2),  IATJL2(LY2,LY2)
     $             ,IALJ3 (LY3,LY3),  IATLJ3(LY3,LY3)
     $             ,IALJ1 (LY1,LY1),  IATLJ1(LY1,LY1)
C     
      REAL   IXM12,IYM12,IZM12,IXM21,IYM21,IZM21
      REAL   IXTM12,IYTM12,IZTM12,IXTM21,IYTM21,IZTM21
      REAL   IXM13,IYM13,IZM13,IXM31,IYM31,IZM31
      REAL   IXTM13,IYTM13,IZTM13,IXTM31,IYTM31,IZTM31
      REAL   IAM12,IAM21,IATM12,IATM21,IAM13,IAM31,IATM13,IATM31
      REAL   ICM12,ICM21,ICTM12,ICTM21,ICM13,ICM31,ICTM13,ICTM31
      REAL   IAJL1,IATJL1,IAJL2,IATJL2,IALJ3,IATLJ3,IALJ1,IATLJ1
# 7 "TOTAL" 2
# 7 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 8 "TOTAL" 2
# 8 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MVGEOM" 1
C     
C     Moving mesh data
C     
# 4
      COMMON /WSOL/   WX    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WY    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WZ    (LX1M,LY1M,LZ1M,LELT)
      COMMON /WLAG/   WXLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WYLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WZLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
      COMMON /WMSU/   W1MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W2MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W3MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   WMULT (LX1M,LY1M,LZ1M,LELT)
      COMMON /EIGVEC/ EV1   (LX1M,LY1M,LZ1M,LELV)
     $              , EV2   (LX1M,LY1M,LZ1M,LELV)
     $              , EV3   (LX1M,LY1M,LZ1M,LELV)
# 9 "TOTAL" 2
# 9 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 10 "TOTAL" 2
# 10 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 11 "TOTAL" 2
# 11 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/STEADY" 1
# 1
      COMMON /SSPAR1/ TAUSS(LDIMT1) , TXNEXT(LDIMT1)
      COMMON /SSPAR2/ NSSKIP
      COMMON /SSPAR3/ IFSKIP, IFMODP, IFSSVT, IFSTST(LDIMT1)
     $              ,                 IFEXVT, IFEXTR(LDIMT1)
      LOGICAL         IFSKIP, IFMODP, IFSSVT, IFSTST
     $              ,                 IFEXVT, IFEXTR
      COMMON /SSNORM/ DVNNH1, DVNNSM, DVNNL2, DVNNL8
     $              , DVDFH1, DVDFSM, DVDFL2, DVDFL8
     $              , DVPRH1, DVPRSM, DVPRL2, DVPRL8
# 12 "TOTAL" 2
# 12 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOPOL" 1
C     
C     Arrays for direct stiffness summation
C     
# 4
      COMMON /CFACES/ NOMLIS(2,3),NMLINV(6),GROUP(6),SKPDAT(6,6)
     $               ,EFACE(6),EFACE1(6)
c     
      INTEGER NOMLIS,NMLINV,GROUP,SKPDAT,EFACE,EFACE1
      COMMON /CEDGES/ ESKIP(-12:12,3),NEDG(3)    ,NCMP
     $               ,IXCN(8),NOFFST(3,0:LDIMT1)
     $               ,MAXMLT,NSPMAX(0:LDIMT1)
     $               ,NGSPCN(0:LDIMT1),NGSPED(3,0:LDIMT1)
     $               ,NUMSCN(LELT,0:LDIMT1),NUMSED(LELT,0:LDIMT1)
     $               ,GCNNUM( 8,LELT,0:LDIMT1),LCNNUM( 8,LELT,0:LDIMT1)
     $               ,GEDNUM(12,LELT,0:LDIMT1),LEDNUM(12,LELT,0:LDIMT1)
     $               ,GEDTYP(12,LELT,0:LDIMT1)
     $               ,NGCOMM(2,0:LDIMT1)
      INTEGER ESKIP,NEDG,IXCN,MAXMLT,NSPMAX,NOFFST,NGSPCN,NGSPED
     $       ,NUMSCN,NUMSED,GCNNUM,LCNNUM,GEDNUM,LEDNUM,GEDTYP
     $       ,NGCOMM
      COMMON /EDGES/ IEDGE(20),IEDGEF(2,4,6,0:1)
     $              ,ICEDG(3,16),IEDGFC(4,6),ICFACE(4,10)
     $              ,INDX(8),INVEDG(27)
      
# 13 "TOTAL" 2
# 13 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 14 "TOTAL" 2
# 14 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TURBO" 1
C     
C       Common block for turbulence model
C     
# 4
      COMMON /TURBR/ VTURB (LX1M,LY1M,LZ1M,LELV)
     $             , TURBL (LX1M,LY1M,LZ1M,LELV)
     $             , UWALL (LX1M,LZ1M,6,LELV)
     $             , ZWALL (LX1M,LZ1M,6,LELV)
     $             , TWX   (LX1M,LZ1M,6,LELV)
     $             , TWY   (LX1M,LZ1M,6,LELV)
     $             , TWZ   (LX1M,LZ1M,6,LELV)
      COMMON /TURBC/ CMU,CMT,SGK,SGE,CE1,CE2,VKC,BTA,SGT
     $             , BETA1,BETA2
     $             , CMI,SKI,SEI,VKI,BTI,STI
     $             , ZPLDAT,ZPUDAT,ZPVDAT,TLMAX,TLIMUL
      COMMON /TURBI/ IFLDK,IFLDTK,IFLDE,IFLDTE
      COMMON /TURBL/ IFSWALL,IFTWSH(6,LELV),IFCWUZ
C     
      
      LOGICAL IFSWALL,IFTWSH,IFCWUZ
# 15 "TOTAL" 2
# 15 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/ESOLV" 1
# 1
      common /econst/ iesolv
      common /efastm/ ifalgn(lelv), ifrsxy(lelv)
      logical         ifalgn, ifrsxy
      common /eouter/ volel(lelv) 
# 16 "TOTAL" 2
# 16 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZ" 1
C     
C     Gauss-Labotto and Gauss points
C     
# 4
      COMMON /GAUSS/ ZGM1(LX1,3), ZGM2(LX2,3), ZGM3(LX3,3)
     $              ,ZAM1(LX1)  , ZAM2(LX2)  , ZAM3(LX3)
C     
C    Weights
C     
      COMMON /WXYZ/ WXM1(LX1), WYM1(LY1), WZM1(LZ1), W3M1(LX1,LY1,LZ1)
     $             ,WXM2(LX2), WYM2(LY2), WZM2(LZ2), W3M2(LX2,LY2,LZ2)
     $             ,WXM3(LX3), WYM3(LY3), WZM3(LZ3), W3M3(LX3,LY3,LZ3)
     $             ,WAM1(LY1), WAM2(LY2), WAM3(LY3)
     $             ,W2AM1(LX1,LY1), W2CM1(LX1,LY1)
     $             ,W2AM2(LX2,LY2), W2CM2(LX2,LY2)
     $             ,W2AM3(LX3,LY3), W2CM3(LX3,LY3)
# 17 "TOTAL" 2
# 17 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZF" 1
c     
c Points (z) and weights (w) on velocity, pressure
c     
c     zgl -- velocity points on Gauss-Lobatto points i = 1,...nx
c     zgp -- pressure points on Gauss         points i = 1,...nxp (nxp =
c     
c     parameter (lxm = lx1)
# 8
      parameter (lxq = lx2)
c     
      common /wz1/   zgl(lx1),wgl(lx1)
     $           ,   zgp(lx1),wgp(lxq)
c     
c     Tensor- (outer-) product of 1D weights   (for volumetric integrati
c     
      common /wz2/  wgl1(lx1*lx1),wgl2(lxq*lxq)
     $           ,  wgli(lx1*lx1)
c     
c     
c    Frequently used derivative matrices:
c     
c    D1, D1t   ---  differentiate on mesh 1 (velocity mesh)
c    D2, D2t   ---  differentiate on mesh 2 (pressure mesh)
c     
c    DXd,DXdt  ---  differentiate from velocity mesh ONTO dealiased mesh
c                   (currently the same as D1 and D1t...)
c     
c     
      common /deriv/  d1    (lx1*lx1) , d1t    (lx1*lx1)
     $             ,  d2    (lx1*lx1) , b2p    (lx1*lx1)
     $             ,  B1iA1 (lx1*lx1) , B1iA1t (lx1*lx1)
     $             ,  da    (lx1*lx1) , dat    (lx1*lx1)
     $             ,  iggl  (lx1*lxq) , igglt  (lx1*lxq)
     $             ,  dglg  (lx1*lxq) , dglgt  (lx1*lxq)
     $             ,  wglg  (lx1*lxq) , wglgt  (lx1*lxq)
      real ixd,ixdt,iggl,igglt
c     
# 18 "TOTAL" 2
# 18 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DSSUM" 1
# 1
      parameter (lds=lx1*ly1*lz1*lelt)
      common /newdss/ ids_lgl1(-1:lds),ids_lgl2(-1:lds),ids_ptr(lds)
# 2265 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2265 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2266 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2266 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      


# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/POPENACC" 1
# 1
      common /spltacc/  ml_acc(lx2*ly2*lz2*lelv)
     $              ,   mu_acc(lx2*ly2*lz2*lelv)
      
      real ml_acc,mu_acc
      
      parameter (lta=lx1*ly1*lz1*lelt)
      common /mgdssum/ mg_lgl1(-1:lta,6)
     $              ,  mg_lgl2(-1:lta,6),mg_ptr(lta,6)
# 2269 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2269 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 2270
      common /scrhi/ h2inv (lx1,ly1,lz1,lelt)
      common /scrvh/ h1    (lx1,ly1,lz1,lelt),
     $               h2    (lx1,ly1,lz1,lelt)
      
      integer p_h1,p_h2,p_g,p_b,p_msk
      
      
      param(59) = 1
      call geom_reset(1)  ! Recompute g1m1 etc. with deformed only
      
      n = nx1*ny1*nz1*nelt
      call rone (h1   ,n)
      call rzero(h2   ,n)
      call rzero(h2inv,n)
      
      call h1mg_setup_mg_nx
      call h1mg_setup_semhat ! SEM hat matrices for each level
      call hsmg_setup_intp   ! Interpolation operators
      



# 2292
      call h1mg_setup_dssum_acc  ! set direct stiffness summation handle

# 2294
      call h1mg_setup_wtmask ! set restriction weight matrices and bc ma
      call h1mg_setup_fdm    ! set up fast diagonalization method
      call h1mg_setup_schwarz_wt(.false.)
      call hsmg_setup_solve  ! set up the solver
      
      l=mg_h1_lmax
      call mg_set_h1  (p_h1 ,l)
      call mg_set_h2  (p_h2 ,l)
      call mg_set_gb  (p_g,p_b,l)
      call mg_set_msk (p_msk,l)
      
      return
      end
c-----------------------------------------------------------------------
      subroutine h1mg_setup_mg_nx()

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2310 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2310 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2311 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2311 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 2312 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2312 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2313 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2313 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SEMHAT" 1
# 1
      parameter (lr2=2*lx1*lx1)
      common /ahat/ ah (lr2),bh (lr2),ch (lr2),dh (lr2)
     $             ,dph(lr2),jph(lr2),zh (lr2),wh (lr2)  ! Pressure GLL
     $             ,bgl(lr2),zgl(lr2),dgl(lr2),jgl(lr2)  ! Pressure GL 
      real ah,bh,ch,dh,dph,jph,zh,wh,bgl,zgl,dgl,jgl
c     
      parameter (l3=lx1*(lx1+1)*(lx1+2)/3)
      parameter (l2=lx1*(lx1+1)/2)
      common /hata/ dd(l3),zp(l2),ww(l2)   ! Aggregate arrays
# 2314 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2314 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 2315 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2315 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real w(lx1+2)
      integer nf,nc,nr
      integer nx,ny,nz
      
      integer mgn2(10)
      save    mgn2
      data    mgn2 / 1, 2, 2, 2, 2, 3, 3, 5, 5, 5/
c     data    mgn2 / 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
      
c     if (param(82).eq.0) param(82)=2  ! nek default
c     if (np.eq.1)        param(82)=2  ! single proc. too slow
      p82 = 2                          ! potentially variable nxc
      mg_h1_lmax = 3
c     mg_h1_lmax = 4
      if (lx1.eq.4) mg_h1_lmax = 2
c     if (param(79).ne.0) mg_h1_lmax = param(79)
      mgnx1    = p82-1 !1
      mg_nx(1) = mgnx1
      mg_ny(1) = mgnx1
      mg_nz(1) = mgnx1
      if (.not.if3d) mg_nz(1) = 0 
      
      mgnx2 = 2*(lx2/4) + 1
      if (lx1.eq.5)  mgnx2 = 3
c     if (lx1.eq.6)  mgnx2 = 3
      if (lx1.le.10) mgnx2 = mgn2(nx1)
      if (lx1.eq.8)  mgnx2 = 4
      if (lx1.eq.8)  mgnx2 = 3
      
      mgnx2 = min(3,mgnx2)  ! This choice seems best (9/24/12)
      
      mg_nx(2) = mgnx2
      mg_ny(2) = mgnx2
      mg_nz(2) = mgnx2
      if (.not.if3d) mg_nz(2) = 0 
      
      mg_nx(3) = mgnx2+1
      mg_ny(3) = mgnx2+1
      mg_nz(3) = mgnx2+1
      if (.not.if3d) mg_nz(3) = 0 
      
      mg_nx(mg_h1_lmax) = lx1-1
      mg_ny(mg_h1_lmax) = ly1-1
      mg_nz(mg_h1_lmax) = lz1-1
      
      if (nid.eq.0) write(*,*) 'h1_mg_nx:',(mg_nx(i),i=1,mg_h1_lmax)
      if (nid.eq.0) write(*,*) 'h1_mg_ny:',(mg_ny(i),i=1,mg_h1_lmax)
      if (nid.eq.0) write(*,*) 'h1_mg_nz:',(mg_nz(i),i=1,mg_h1_lmax)
      
      do ifld=1,ldimt1
      do l=1,mg_lmax
         mg_h1_n(l,ifld)=(mg_nx(l)+1)
     $                  *(mg_ny(l)+1)
     $                  *(mg_nz(l)+1)*nelfld(ifld)
      enddo
      enddo
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_semhat ! SEM hat matrices for each level

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2377 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2377 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2378 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2378 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2379 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2379 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SEMHAT" 1
# 1
      parameter (lr2=2*lx1*lx1)
      common /ahat/ ah (lr2),bh (lr2),ch (lr2),dh (lr2)
     $             ,dph(lr2),jph(lr2),zh (lr2),wh (lr2)  ! Pressure GLL
     $             ,bgl(lr2),zgl(lr2),dgl(lr2),jgl(lr2)  ! Pressure GL 
      real ah,bh,ch,dh,dph,jph,zh,wh,bgl,zgl,dgl,jgl
c     
      parameter (l3=lx1*(lx1+1)*(lx1+2)/3)
      parameter (l2=lx1*(lx1+1)/2)
      common /hata/ dd(l3),zp(l2),ww(l2)   ! Aggregate arrays
# 2380 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2380 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      do l=1,mg_h1_lmax
         n = mg_nx(l)     ! polynomial order
         call semhat(ah,bh,ch,dh,zh,dph,jph,bgl,zgl,dgl,jgl,n,wh)
         call copy(mg_ah(1,l),ah,(n+1)*(n+1))
         call copy(mg_bh(1,l),bh,n+1)
         call copy(mg_dh(1,l),dh,(n+1)*(n+1))
         call transpose(mg_dht(1,l),n+1,dh,n+1)
         call copy(mg_zh(1,l),zh,n+1)
      
         mg_nh(l)=n+1
         mg_nhz(l)=mg_nz(l)+1
      
      enddo
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_dssum

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2398 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2398 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2399 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2399 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 2400 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2400 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2401 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2401 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter (lxyz=(lx1+2)*(ly1+2)*(lz1+2))
      common /c_is1/ glo_num(lxyz*lelt)
      common /ivrtx/ vertex ((2**ldim)*lelt)
      
      integer*8 glo_num
      integer vertex
      integer nx,ny,nz
      integer l
      
      ncrnr = 2**ndim
      call get_vert
      
      
      do l=1,mg_lmax  ! set up direct stiffness summation for each level
         nx=mg_nh(l)
         ny=mg_nh(l)
         nz=mg_nhz(l)
         call setupds(mg_gsh_handle(l,mg_fld),nx,ny,nz
     $                ,nelv,nelgv,vertex,glo_num)
         nx=nx+2
         ny=ny+2
         nz=nz+2
         if(.not.if3d) nz=1
         call setupds(mg_gsh_schwarz_handle(l,mg_fld),nx,ny,nz
     $                ,nelv,nelgv,vertex,glo_num)
      enddo
      
      return
      end
c----------------------------------------------------------------------
      subroutine mg_set_msk(p_msk ,l0)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2433 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2433 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2434 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2434 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 2435 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2435 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer p_msk
      
      l                  = mg_h1_lmax
      p_mg_msk(l,mg_fld) = 0
      n                  = mg_h1_n(l,mg_fld)
      
      
      do l=mg_h1_lmax,1,-1
         nx = mg_nh  (l)
         ny = mg_nh  (l)
         nz = mg_nhz (l)
      
         p_msk = p_mg_msk(l,mg_fld)
      
         call h1mg_setup_mask
     $     (mg_imask(p_msk),nm,nx,ny,nz,nelfld(ifield),l,mg_work)
      
         if (l.gt.1) p_mg_msk(l-1,mg_fld)=p_mg_msk(l,mg_fld)+nm
      
      enddo
      
      p_msk = p_mg_msk(l0,mg_fld)
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_mask(mask,nm,nx,ny,nz,nel,l,w)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2463 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2463 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2464 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2464 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer mask(1)        ! Pointer to Dirichlet BCs
      integer nx,ny,nz,l
      real w(nx,ny,nz,nel)
      
      integer e,count,ptr
      integer lbr,rbr,lbs,rbs,lbt,rbt
      
      zero = 0
      nxyz = nx*ny*nz
      n    = nx*ny*nz*nel
      
      call rone(w,n)   ! Init everything to 1
      
      ierrmx = 0       ! BC verification
      do e=1,nel       ! Set dirichlet nodes to zero
      
         call get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,e,2,ierr)
c        write(6,6) e,lbr,rbr,lbs,rbs,ierr,nx
c   6    format(i5,2x,4i3,2x,i2,3x,i5,'  lbr,rbr,lbs')
      
         if (lbr.eq.1) call facev(w,e,4,zero,nx,ny,nz)
         if (rbr.eq.1) call facev(w,e,2,zero,nx,ny,nz)
         if (lbs.eq.1) call facev(w,e,1,zero,nx,ny,nz)
         if (rbs.eq.1) call facev(w,e,3,zero,nx,ny,nz)
         if (if3d) then
            if (lbt.eq.1) call facev(w,e,5,zero,nx,ny,nz)
            if (rbt.eq.1) call facev(w,e,6,zero,nx,ny,nz)
         endif
         ierrmx = max(ierrmx,ierr)
      enddo
      
      call hsmg_dsprod(w,l)    ! direct stiffness multiply
      
c     
c     Prototypical mask layout, nel=5:
c     
c    e=1 ...             10
c      1  2  3  4  5 ... 10 | 11 12 13 14 | 15 | 16 |
c     11 15 16 ...          |  3 p1 p2 p3 |  0 |  0 | ...
c                              ^
c                              |
c                              |_count for e=1
c     
      
      nm  = 1                  ! store mask
      do e=1,nel
      
         mask(e) = nel+nm
         count   = 0          ! # Dirchlet points on element e
         ptr     = mask(e)
      
         do i=1,nxyz
            if (w(i,1,1,e).eq.0) then
               nm    = nm   +1
               count = count+1
               ptr   = ptr  +1
               mask(ptr) = i + nxyz*(e-1)   ! where I mask on element e 
            endif
         enddo
      
      
         ptr       = mask(e)
         mask(ptr) = count
      
         nm        = nm+1     ! bump pointer to hold next count
      
      enddo
      
      nm = nel + nm-1 ! Return total number of mask pointers/counters
      
      ierrmx = iglmax(ierrmx,1)
      if (ierrmx.gt.0) then
         if (ierr.gt.0) write(6,*) nid,ierr,' BC FAIL h1'
         call exitti('D INVALID BC FOUND in h1mg_setup_mask$',ierrmx)
      endif
      
      return
      end
c----------------------------------------------------------------------
      subroutine mg_set_h1  (p_h1 ,l0)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2546 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2546 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2547 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2547 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer pf,pc
      
c     As a first pass, rely on the cheesy common-block interface to get 
      
      common /scrvh/ h1    (lx1,ly1,lz1,lelv)
     $             , h2    (lx1,ly1,lz1,lelv)
     $             , h2inv (lx1,ly1,lz1,lelv)
      
      integer p_h1
      
      l                 = mg_h1_lmax
      p_mg_h1(l,mg_fld) = 0
      n                 = mg_h1_n(l,mg_fld)
      
      call copy (mg_h1,h1,n)   ! Fine grid is just original h1
      
      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nhz(l)
      
      do l=mg_h1_lmax-1,1,-1
      
         p_mg_h1(l,mg_fld) = p_mg_h1(l+1,mg_fld) + n
         n                 = mg_h1_n(l  ,mg_fld)
      
         pf                = p_mg_h1(l+1,mg_fld)
         pc                = p_mg_h1(l  ,mg_fld)
      
         call hsmg_intp_fc (mg_h1(pc),mg_h1(pf),l)
      
      enddo
      
      p_h1 = p_mg_h1(l0,mg_fld)
      
      return
      end
c-----------------------------------------------------------------------
      subroutine mg_set_h2  (p_h2 ,l0)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2586 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2586 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2587 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2587 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
c     As a first pass, rely on the cheesy common-block interface to get 
      
      common /scrvh/ h1    (lx1,ly1,lz1,lelv)
     $             , h2    (lx1,ly1,lz1,lelv)
     $             , h2inv (lx1,ly1,lz1,lelv)
      
      integer p_h2,pf,pc
      
      l                 = mg_h1_lmax
      p_mg_h2(l,mg_fld) = 0
      n                 = mg_h1_n(l,mg_fld)
      
      call copy (mg_h2,h2,n)   ! Fine grid is just original h2
      
      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nhz(l)
      
      do l=mg_h1_lmax-1,1,-1
      
         p_mg_h2(l,mg_fld) = p_mg_h2(l+1,mg_fld) + n
         n                 = mg_h1_n(l  ,mg_fld)
      
         pf                = p_mg_h2(l+1,mg_fld)
         pc                = p_mg_h2(l  ,mg_fld)
      
         call hsmg_intp_fc (mg_h2(pc),mg_h2(pf),l)
      
      enddo
      
      p_h2 = p_mg_h2(l0,mg_fld)
      
      return
      end
c-----------------------------------------------------------------------
      subroutine hsmg_intp_fc(uc,uf,l) ! l is coarse level
      

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2626 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2626 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2627 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2627 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real uc(1),uf(1)
      
      
      nc = mg_nh(l)
      nf = mg_nh(l+1)
      call hsmg_tnsr(uc,nc,uf,nf,mg_jhfc(1,l),mg_jhfct(1,l))
      
      return
      end
c-----------------------------------------------------------------------
      subroutine mg_intp_fc_e(uc,uf,nxc,nyc,nzc,nxf,nyf,nzf,e,l,w)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2640 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2640 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2641 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2641 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2642 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2642 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real uf(nxf,nyf,nzf),uc(nxc,nyc,nzc),w(1)
      
      if (if3d) then
      
         n1=nxf*nyf
         n2=nzf
         n3=nzc
         call mxm(uf,n1,mg_jhfct(1,l),n2,w,n3)
      
         lf=1           ! pointers into work array w()
         lc=1 + n1*n3
         lc0=lc
      
         n1=nxf
         n2=nyf
         n3=nyc
      
         do k=1,nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,w(lc),n3)
            lf = lf + n1*n2
            lc = lc + n1*n3
         enddo
      
         lf=lc0  ! Rewind fine pointer to start of coarse data
         n1=nxc
         n2=nxf
         n3=nyc*nzc
         call mxm(mg_jhfc(1,l),n1,w(lf),n2,uc,n3)
      
      else ! 2D
      
         n1=nxf
         n2=nyf
         n3=nyc
         call mxm(uf,n1,mg_jhfct(1,l),n2,w,n3)
      
         n1=nxc
         n2=nxf
         n3=nyc
         call mxm(mg_jhfc(1,l),n1,w,n2,uc,n3)
      
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine mg_intp_gfc_e(gc,gf,ng,nxc,nyc,nzc,nxf,nyf,nzf,e,l,w)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2691 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2691 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2692 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2692 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2693 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2693 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real gf(ng,nxf,nyf,nzf),gc(ng,nxc,nyc,nzc),w(1)
      
      
      if (if3d) then
      
         n1=ng*nxf*nyf
         n2=nzf
         n3=nzc
         call mxm(gf,n1,mg_jhfct(1,l),n2,w,n3)
      
         lf=1           ! pointers into work array w()
         lc=1 + n1*n3
         lc0=lc
      
         n1=ng*nxf
         n2=nyf
         n3=nyc
      
         do k=1,nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,w(lc),n3)
            lf = lf + n1*n2
            lc = lc + n1*n3
         enddo
      
         lf=lc0  ! Rewind fine pointer to start of coarse data
         n1=ng
         n2=nxf
         n3=nxc
      
         do k=1,nyc*nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,gc(1,1,k,1),n3)
            lf = lf + n1*n2
         enddo
      
      else ! 2D
      
         n1=ng*nxf
         n2=nyf
         n3=nyc
         call mxm(gf,n1,mg_jhfct(1,l),n2,w,n3)
      
         lf=1           ! pointers into work array w()
      
         n1=ng
         n2=nxf
         n3=nxc
      
         do k=1,nyc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,gc(1,1,k,1),n3)
            lf = lf + n1*n2
         enddo
      
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine mg_scale_mass (b,g,wt,ng,nx,ny,nz,wk,ifinv)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2753 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2753 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 2754 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2754 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2755 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2755 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real b(1),g(ng,1),wt(1),wk(1)
      logical ifinv
      
      common /ctmp0/ wi(2*lx1+4)
      
      n = nx*ny*nz
      
      if (nx.le.2*lx1) then
         if (ifinv) then
            call invers2(wi,wt,nx)
         else
            call copy(wi,wt,nx)
         endif
      else
         call exitti('mg_scale_mass: wi too small$',nx)
      endif
      
      if (if3d) then
         l=0
         do k=1,nz
         do j=1,ny
            wjk=wi(j)*wi(k)
            do i=1,nx
               l=l+1
               wk(l) = wjk*wi(i)
            enddo
         enddo
         enddo
      
         do k=1,n
            b(k)   = wk(k)*b(k)
            g(1,k) = wk(k)*g(1,k)
            g(2,k) = wk(k)*g(2,k)
            g(3,k) = wk(k)*g(3,k)
            g(4,k) = wk(k)*g(4,k)
            g(5,k) = wk(k)*g(5,k)
            g(6,k) = wk(k)*g(6,k)
         enddo
      
      else      ! 2D
         l=0
         do j=1,ny
         do i=1,nx
            l=l+1
            wk(l) = wi(i)*wi(j)
         enddo
         enddo
      
         do k=1,n
            b(k)   = wk(k)*b(k)
            g(1,k) = wk(k)*g(1,k)
            g(2,k) = wk(k)*g(2,k)
            g(3,k) = wk(k)*g(3,k)
         enddo
      
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine mg_set_gb  (p_g,p_b,l0)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2818 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2818 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2819 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2819 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 2820 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2820 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 2821 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2821 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer p_g,p_b,e
      common /ctmp1/ w(lx1*ly1*lz1*lelt*2)
      
      l                 = mg_h1_lmax
      p_mg_b (l,mg_fld) = 0
      p_mg_g (l,mg_fld) = 0
      n                 = mg_h1_n(l,mg_fld)
      
      
      ng = 3*(ndim-1)  ! 3 or 6 elements to symm dxd tensor
      
      do l=mg_h1_lmax-1,1,-1
      
         p_mg_b (l,mg_fld) = p_mg_b (l+1,mg_fld) + n
         p_mg_g (l,mg_fld) = p_mg_g (l+1,mg_fld) + n*ng
         n                 = mg_h1_n(l  ,mg_fld)
      
      enddo
      
      do e=1,nelfld(ifield)
       do l=mg_h1_lmax,1,-1
      
         nx = mg_nh(l)
         ny = mg_nh(l)
         nz = mg_nhz(l)
         nxyz = nx*ny*nz
      
         p_g = p_mg_g (l,mg_fld) + ng*nx*ny*nz*(e-1)
         p_b = p_mg_b (l,mg_fld) +    nx*ny*nz*(e-1)
      
         if (l.eq.mg_h1_lmax) then
            call gxfer_e (mg_g(p_g) ,ng,e             ) ! Fine grid=orig
            call copy    (mg_b(p_b) ,bm1(1,1,1,e),nxyz) ! Fine grid=orig
            call mg_scale_mass                          ! Divide out Wgh
     $         (mg_b(p_b),mg_g(p_g),mg_bh(1,l),ng,nx,ny,nz,w,.true.)
         else
      
c           Generate G and B by interpolating their continous counterpar
c           the coarse grid and collocating with coarse-grid quadrature 
      
            call mg_intp_gfc_e
     $            (mg_g(p_g),mg_g(l_g),ng,nx,ny,nz,nxl,nyl,nzl,e,l,w)
      
            call mg_intp_fc_e
     $            (mg_b(p_b),mg_b(l_b)   ,nx,ny,nz,nxl,nyl,nzl,e,l,w)
      
            call mg_scale_mass                         ! Reinstate weigh
     $      (mg_b(l_b),mg_g(l_g),mg_bh(1,l+1),ng,nxl,nyl,nzl,w,.false.)
      
         endif
      
         l_b = p_b
         l_g = p_g
      
         nxl = nx
         nyl = ny
         nzl = nz
      
       enddo
      
       call mg_scale_mass                         ! Reinstate weights
     $      (mg_b(l_b),mg_g(l_g),mg_bh(1,1),ng,nxl,nyl,nzl,w,.false.)
      
      
      enddo
      
      p_b  = p_mg_b (l0,mg_fld)
      p_g  = p_mg_g (l0,mg_fld)
      
      return
      end
c-----------------------------------------------------------------------
      subroutine gxfer_e (g,ng,e) 

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2896 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2896 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOTAL" 1

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DXYZ" 1
C     
C     Elemental derivative operators
C     
# 4
      COMMON /DXYZ/ DXM1(LX1,LX1),  DXM12(LX2,LX1)
     $             ,DYM1(LY1,LY1),  DYM12(LY2,LY1)
     $             ,DZM1(LZ1,LZ1),  DZM12(LZ2,LZ1)
     $             ,DXTM1(LX1,LX1), DXTM12(LX1,LX2)
     $             ,DYTM1(LY1,LY1), DYTM12(LY1,LY2)
     $             ,DZTM1(LZ1,LZ1), DZTM12(LZ1,LZ2)
     $             ,DXM3(LX3,LX3),  DXTM3(LX3,LX3)
     $             ,DYM3(LY3,LY3),  DYTM3(LY3,LY3)
     $             ,DZM3(LZ3,LZ3),  DZTM3(LZ3,LZ3)
     $             ,DCM1(LY1,LY1),  DCTM1(LY1,LY1)
     $             ,DCM3(LY3,LY3),  DCTM3(LY3,LY3)
     $             ,DCM12(LY2,LY1), DCTM12(LY1,LY2)
     $             ,DAM1(LY1,LY1),  DATM1(LY1,LY1)
     $             ,DAM12(LY2,LY1), DATM12(LY1,LY2)
     $             ,DAM3(LY3,LY3),  DATM3(LY3,LY3)
      
# 2 "TOTAL" 2
# 2 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DEALIAS" 1
# 1
      common /solnd/  vxd(lxd,lyd,lzd,lelv)
     $             ,  vyd(lxd,lyd,lzd,lelv)
     $             ,  vzd(lxd,lyd,lzd,lelv)
      common /interpd/ imd1(lx1,lxd),imd1t(lxd,lx1)
     $               , im1d(lxd,lx1),im1dt(lx1,lxd)
     $               , pmd1(lx1,lxd),pmd1t(lxd,lx1)
c     common /dedim/ nxd,nyd,nzd
      real imd1,imd1t,im1d,im1dt
c     
# 3 "TOTAL" 2
# 3 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/EIGEN" 1
C     
C     Eigenvalues
C     
# 4
      COMMON /EIGVAL/ EIGAA, EIGAS, EIGAST, EIGAE
     $               ,EIGGA, EIGGS, EIGGST, EIGGE
      COMMON /IFEIG / IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      LOGICAL         IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      
# 4 "TOTAL" 2
# 4 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 5 "TOTAL" 2
# 5 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 6 "TOTAL" 2
# 6 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/IXYZ" 1
C     
C     Interpolation operators
C     
# 4
      COMMON /IXYZ/ IXM12 (LX2,LX1),  IXM21 (LX1,LX2)
     $             ,IYM12 (LY2,LY1),  IYM21 (LY1,LY2)
     $             ,IZM12 (LZ2,LZ1),  IZM21 (LZ1,LZ2)
     $             ,IXTM12(LX1,LX2),  IXTM21(LX2,LX1)
     $             ,IYTM12(LY1,LY2),  IYTM21(LY2,LY1)
     $             ,IZTM12(LZ1,LZ2),  IZTM21(LZ2,LZ1)
     $             ,IXM13 (LX3,LX1),  IXM31 (LX1,LX3)
     $             ,IYM13 (LY3,LY1),  IYM31 (LY1,LY3)
     $             ,IZM13 (LZ3,LZ1),  IZM31 (LZ1,LZ3)
     $             ,IXTM13(LX1,LX3),  IXTM31(LX3,LX1)
     $             ,IYTM13(LY1,LY3),  IYTM31(LY3,LY1)
     $             ,IZTM13(LZ1,LZ3),  IZTM31(LZ3,LZ1)
      COMMON /IXYZA/
     $              IAM12 (LY2,LY1),  IAM21 (LY1,LY2)
     $             ,IATM12(LY1,LY2),  IATM21(LY2,LY1)
     $             ,IAM13 (LY3,LY1),  IAM31 (LY1,LY3)
     $             ,IATM13(LY1,LY3),  IATM31(LY3,LY1)
     $             ,ICM12 (LY2,LY1),  ICM21 (LY1,LY2)
     $             ,ICTM12(LY1,LY2),  ICTM21(LY2,LY1)
     $             ,ICM13 (LY3,LY1),  ICM31 (LY1,LY3)
     $             ,ICTM13(LY1,LY3),  ICTM31(LY3,LY1)
     $             ,IAJL1 (LY1,LY1),  IATJL1(LY1,LY1)
     $             ,IAJL2 (LY2,LY2),  IATJL2(LY2,LY2)
     $             ,IALJ3 (LY3,LY3),  IATLJ3(LY3,LY3)
     $             ,IALJ1 (LY1,LY1),  IATLJ1(LY1,LY1)
C     
      REAL   IXM12,IYM12,IZM12,IXM21,IYM21,IZM21
      REAL   IXTM12,IYTM12,IZTM12,IXTM21,IYTM21,IZTM21
      REAL   IXM13,IYM13,IZM13,IXM31,IYM31,IZM31
      REAL   IXTM13,IYTM13,IZTM13,IXTM31,IYTM31,IZTM31
      REAL   IAM12,IAM21,IATM12,IATM21,IAM13,IAM31,IATM13,IATM31
      REAL   ICM12,ICM21,ICTM12,ICTM21,ICM13,ICM31,ICTM13,ICTM31
      REAL   IAJL1,IATJL1,IAJL2,IATJL2,IALJ3,IATLJ3,IALJ1,IATLJ1
# 7 "TOTAL" 2
# 7 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 8 "TOTAL" 2
# 8 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MVGEOM" 1
C     
C     Moving mesh data
C     
# 4
      COMMON /WSOL/   WX    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WY    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WZ    (LX1M,LY1M,LZ1M,LELT)
      COMMON /WLAG/   WXLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WYLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WZLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
      COMMON /WMSU/   W1MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W2MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W3MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   WMULT (LX1M,LY1M,LZ1M,LELT)
      COMMON /EIGVEC/ EV1   (LX1M,LY1M,LZ1M,LELV)
     $              , EV2   (LX1M,LY1M,LZ1M,LELV)
     $              , EV3   (LX1M,LY1M,LZ1M,LELV)
# 9 "TOTAL" 2
# 9 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 10 "TOTAL" 2
# 10 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 11 "TOTAL" 2
# 11 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/STEADY" 1
# 1
      COMMON /SSPAR1/ TAUSS(LDIMT1) , TXNEXT(LDIMT1)
      COMMON /SSPAR2/ NSSKIP
      COMMON /SSPAR3/ IFSKIP, IFMODP, IFSSVT, IFSTST(LDIMT1)
     $              ,                 IFEXVT, IFEXTR(LDIMT1)
      LOGICAL         IFSKIP, IFMODP, IFSSVT, IFSTST
     $              ,                 IFEXVT, IFEXTR
      COMMON /SSNORM/ DVNNH1, DVNNSM, DVNNL2, DVNNL8
     $              , DVDFH1, DVDFSM, DVDFL2, DVDFL8
     $              , DVPRH1, DVPRSM, DVPRL2, DVPRL8
# 12 "TOTAL" 2
# 12 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOPOL" 1
C     
C     Arrays for direct stiffness summation
C     
# 4
      COMMON /CFACES/ NOMLIS(2,3),NMLINV(6),GROUP(6),SKPDAT(6,6)
     $               ,EFACE(6),EFACE1(6)
c     
      INTEGER NOMLIS,NMLINV,GROUP,SKPDAT,EFACE,EFACE1
      COMMON /CEDGES/ ESKIP(-12:12,3),NEDG(3)    ,NCMP
     $               ,IXCN(8),NOFFST(3,0:LDIMT1)
     $               ,MAXMLT,NSPMAX(0:LDIMT1)
     $               ,NGSPCN(0:LDIMT1),NGSPED(3,0:LDIMT1)
     $               ,NUMSCN(LELT,0:LDIMT1),NUMSED(LELT,0:LDIMT1)
     $               ,GCNNUM( 8,LELT,0:LDIMT1),LCNNUM( 8,LELT,0:LDIMT1)
     $               ,GEDNUM(12,LELT,0:LDIMT1),LEDNUM(12,LELT,0:LDIMT1)
     $               ,GEDTYP(12,LELT,0:LDIMT1)
     $               ,NGCOMM(2,0:LDIMT1)
      INTEGER ESKIP,NEDG,IXCN,MAXMLT,NSPMAX,NOFFST,NGSPCN,NGSPED
     $       ,NUMSCN,NUMSED,GCNNUM,LCNNUM,GEDNUM,LEDNUM,GEDTYP
     $       ,NGCOMM
      COMMON /EDGES/ IEDGE(20),IEDGEF(2,4,6,0:1)
     $              ,ICEDG(3,16),IEDGFC(4,6),ICFACE(4,10)
     $              ,INDX(8),INVEDG(27)
      
# 13 "TOTAL" 2
# 13 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 14 "TOTAL" 2
# 14 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TURBO" 1
C     
C       Common block for turbulence model
C     
# 4
      COMMON /TURBR/ VTURB (LX1M,LY1M,LZ1M,LELV)
     $             , TURBL (LX1M,LY1M,LZ1M,LELV)
     $             , UWALL (LX1M,LZ1M,6,LELV)
     $             , ZWALL (LX1M,LZ1M,6,LELV)
     $             , TWX   (LX1M,LZ1M,6,LELV)
     $             , TWY   (LX1M,LZ1M,6,LELV)
     $             , TWZ   (LX1M,LZ1M,6,LELV)
      COMMON /TURBC/ CMU,CMT,SGK,SGE,CE1,CE2,VKC,BTA,SGT
     $             , BETA1,BETA2
     $             , CMI,SKI,SEI,VKI,BTI,STI
     $             , ZPLDAT,ZPUDAT,ZPVDAT,TLMAX,TLIMUL
      COMMON /TURBI/ IFLDK,IFLDTK,IFLDE,IFLDTE
      COMMON /TURBL/ IFSWALL,IFTWSH(6,LELV),IFCWUZ
C     
      
      LOGICAL IFSWALL,IFTWSH,IFCWUZ
# 15 "TOTAL" 2
# 15 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/ESOLV" 1
# 1
      common /econst/ iesolv
      common /efastm/ ifalgn(lelv), ifrsxy(lelv)
      logical         ifalgn, ifrsxy
      common /eouter/ volel(lelv) 
# 16 "TOTAL" 2
# 16 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZ" 1
C     
C     Gauss-Labotto and Gauss points
C     
# 4
      COMMON /GAUSS/ ZGM1(LX1,3), ZGM2(LX2,3), ZGM3(LX3,3)
     $              ,ZAM1(LX1)  , ZAM2(LX2)  , ZAM3(LX3)
C     
C    Weights
C     
      COMMON /WXYZ/ WXM1(LX1), WYM1(LY1), WZM1(LZ1), W3M1(LX1,LY1,LZ1)
     $             ,WXM2(LX2), WYM2(LY2), WZM2(LZ2), W3M2(LX2,LY2,LZ2)
     $             ,WXM3(LX3), WYM3(LY3), WZM3(LZ3), W3M3(LX3,LY3,LZ3)
     $             ,WAM1(LY1), WAM2(LY2), WAM3(LY3)
     $             ,W2AM1(LX1,LY1), W2CM1(LX1,LY1)
     $             ,W2AM2(LX2,LY2), W2CM2(LX2,LY2)
     $             ,W2AM3(LX3,LY3), W2CM3(LX3,LY3)
# 17 "TOTAL" 2
# 17 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZF" 1
c     
c Points (z) and weights (w) on velocity, pressure
c     
c     zgl -- velocity points on Gauss-Lobatto points i = 1,...nx
c     zgp -- pressure points on Gauss         points i = 1,...nxp (nxp =
c     
c     parameter (lxm = lx1)
# 8
      parameter (lxq = lx2)
c     
      common /wz1/   zgl(lx1),wgl(lx1)
     $           ,   zgp(lx1),wgp(lxq)
c     
c     Tensor- (outer-) product of 1D weights   (for volumetric integrati
c     
      common /wz2/  wgl1(lx1*lx1),wgl2(lxq*lxq)
     $           ,  wgli(lx1*lx1)
c     
c     
c    Frequently used derivative matrices:
c     
c    D1, D1t   ---  differentiate on mesh 1 (velocity mesh)
c    D2, D2t   ---  differentiate on mesh 2 (pressure mesh)
c     
c    DXd,DXdt  ---  differentiate from velocity mesh ONTO dealiased mesh
c                   (currently the same as D1 and D1t...)
c     
c     
      common /deriv/  d1    (lx1*lx1) , d1t    (lx1*lx1)
     $             ,  d2    (lx1*lx1) , b2p    (lx1*lx1)
     $             ,  B1iA1 (lx1*lx1) , B1iA1t (lx1*lx1)
     $             ,  da    (lx1*lx1) , dat    (lx1*lx1)
     $             ,  iggl  (lx1*lxq) , igglt  (lx1*lxq)
     $             ,  dglg  (lx1*lxq) , dglgt  (lx1*lxq)
     $             ,  wglg  (lx1*lxq) , wglgt  (lx1*lxq)
      real ixd,ixdt,iggl,igglt
c     
# 18 "TOTAL" 2
# 18 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DSSUM" 1
# 1
      parameter (lds=lx1*ly1*lz1*lelt)
      common /newdss/ ids_lgl1(-1:lds),ids_lgl2(-1:lds),ids_ptr(lds)
# 2897 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2897 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real g(ng,1)
      integer e
      
      nxyz = nx1*ny1*nz1
      
c     ifdfrm(e) = .true.  ! TOO LATE
      
      if (if3d) then
         do i=1,nxyz
            g(1,i) = g1m1(i,1,1,e)
            g(2,i) = g2m1(i,1,1,e)
            g(3,i) = g3m1(i,1,1,e)
            g(4,i) = g4m1(i,1,1,e)
            g(5,i) = g5m1(i,1,1,e)
            g(6,i) = g6m1(i,1,1,e)
         enddo
      else
         do i=1,nxyz
            g(1,i) = g1m1(i,1,1,e)
            g(2,i) = g2m1(i,1,1,e)
            g(3,i) = g4m1(i,1,1,e)
         enddo
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine chkr(name3,ii)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2927 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2927 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOTAL" 1

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DXYZ" 1
C     
C     Elemental derivative operators
C     
# 4
      COMMON /DXYZ/ DXM1(LX1,LX1),  DXM12(LX2,LX1)
     $             ,DYM1(LY1,LY1),  DYM12(LY2,LY1)
     $             ,DZM1(LZ1,LZ1),  DZM12(LZ2,LZ1)
     $             ,DXTM1(LX1,LX1), DXTM12(LX1,LX2)
     $             ,DYTM1(LY1,LY1), DYTM12(LY1,LY2)
     $             ,DZTM1(LZ1,LZ1), DZTM12(LZ1,LZ2)
     $             ,DXM3(LX3,LX3),  DXTM3(LX3,LX3)
     $             ,DYM3(LY3,LY3),  DYTM3(LY3,LY3)
     $             ,DZM3(LZ3,LZ3),  DZTM3(LZ3,LZ3)
     $             ,DCM1(LY1,LY1),  DCTM1(LY1,LY1)
     $             ,DCM3(LY3,LY3),  DCTM3(LY3,LY3)
     $             ,DCM12(LY2,LY1), DCTM12(LY1,LY2)
     $             ,DAM1(LY1,LY1),  DATM1(LY1,LY1)
     $             ,DAM12(LY2,LY1), DATM12(LY1,LY2)
     $             ,DAM3(LY3,LY3),  DATM3(LY3,LY3)
      
# 2 "TOTAL" 2
# 2 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DEALIAS" 1
# 1
      common /solnd/  vxd(lxd,lyd,lzd,lelv)
     $             ,  vyd(lxd,lyd,lzd,lelv)
     $             ,  vzd(lxd,lyd,lzd,lelv)
      common /interpd/ imd1(lx1,lxd),imd1t(lxd,lx1)
     $               , im1d(lxd,lx1),im1dt(lx1,lxd)
     $               , pmd1(lx1,lxd),pmd1t(lxd,lx1)
c     common /dedim/ nxd,nyd,nzd
      real imd1,imd1t,im1d,im1dt
c     
# 3 "TOTAL" 2
# 3 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/EIGEN" 1
C     
C     Eigenvalues
C     
# 4
      COMMON /EIGVAL/ EIGAA, EIGAS, EIGAST, EIGAE
     $               ,EIGGA, EIGGS, EIGGST, EIGGE
      COMMON /IFEIG / IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      LOGICAL         IFAA,IFAE,IFAS,IFAST,IFGA,IFGE,IFGS,IFGST
      
# 4 "TOTAL" 2
# 4 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 5 "TOTAL" 2
# 5 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 6 "TOTAL" 2
# 6 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/IXYZ" 1
C     
C     Interpolation operators
C     
# 4
      COMMON /IXYZ/ IXM12 (LX2,LX1),  IXM21 (LX1,LX2)
     $             ,IYM12 (LY2,LY1),  IYM21 (LY1,LY2)
     $             ,IZM12 (LZ2,LZ1),  IZM21 (LZ1,LZ2)
     $             ,IXTM12(LX1,LX2),  IXTM21(LX2,LX1)
     $             ,IYTM12(LY1,LY2),  IYTM21(LY2,LY1)
     $             ,IZTM12(LZ1,LZ2),  IZTM21(LZ2,LZ1)
     $             ,IXM13 (LX3,LX1),  IXM31 (LX1,LX3)
     $             ,IYM13 (LY3,LY1),  IYM31 (LY1,LY3)
     $             ,IZM13 (LZ3,LZ1),  IZM31 (LZ1,LZ3)
     $             ,IXTM13(LX1,LX3),  IXTM31(LX3,LX1)
     $             ,IYTM13(LY1,LY3),  IYTM31(LY3,LY1)
     $             ,IZTM13(LZ1,LZ3),  IZTM31(LZ3,LZ1)
      COMMON /IXYZA/
     $              IAM12 (LY2,LY1),  IAM21 (LY1,LY2)
     $             ,IATM12(LY1,LY2),  IATM21(LY2,LY1)
     $             ,IAM13 (LY3,LY1),  IAM31 (LY1,LY3)
     $             ,IATM13(LY1,LY3),  IATM31(LY3,LY1)
     $             ,ICM12 (LY2,LY1),  ICM21 (LY1,LY2)
     $             ,ICTM12(LY1,LY2),  ICTM21(LY2,LY1)
     $             ,ICM13 (LY3,LY1),  ICM31 (LY1,LY3)
     $             ,ICTM13(LY1,LY3),  ICTM31(LY3,LY1)
     $             ,IAJL1 (LY1,LY1),  IATJL1(LY1,LY1)
     $             ,IAJL2 (LY2,LY2),  IATJL2(LY2,LY2)
     $             ,IALJ3 (LY3,LY3),  IATLJ3(LY3,LY3)
     $             ,IALJ1 (LY1,LY1),  IATLJ1(LY1,LY1)
C     
      REAL   IXM12,IYM12,IZM12,IXM21,IYM21,IZM21
      REAL   IXTM12,IYTM12,IZTM12,IXTM21,IYTM21,IZTM21
      REAL   IXM13,IYM13,IZM13,IXM31,IYM31,IZM31
      REAL   IXTM13,IYTM13,IZTM13,IXTM31,IYTM31,IZTM31
      REAL   IAM12,IAM21,IATM12,IATM21,IAM13,IAM31,IATM13,IATM31
      REAL   ICM12,ICM21,ICTM12,ICTM21,ICM13,ICM31,ICTM13,ICTM31
      REAL   IAJL1,IATJL1,IAJL2,IATJL2,IALJ3,IATLJ3,IALJ1,IATLJ1
# 7 "TOTAL" 2
# 7 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 8 "TOTAL" 2
# 8 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MVGEOM" 1
C     
C     Moving mesh data
C     
# 4
      COMMON /WSOL/   WX    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WY    (LX1M,LY1M,LZ1M,LELT)
     $            ,   WZ    (LX1M,LY1M,LZ1M,LELT)
      COMMON /WLAG/   WXLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WYLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
     $            ,   WZLAG (LX1M,LY1M,LZ1M,LELT,LORDER-1)
      COMMON /WMSU/   W1MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W2MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   W3MASK(LX1M,LY1M,LZ1M,LELT)
     $            ,   WMULT (LX1M,LY1M,LZ1M,LELT)
      COMMON /EIGVEC/ EV1   (LX1M,LY1M,LZ1M,LELV)
     $              , EV2   (LX1M,LY1M,LZ1M,LELV)
     $              , EV3   (LX1M,LY1M,LZ1M,LELV)
# 9 "TOTAL" 2
# 9 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 10 "TOTAL" 2
# 10 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 11 "TOTAL" 2
# 11 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/STEADY" 1
# 1
      COMMON /SSPAR1/ TAUSS(LDIMT1) , TXNEXT(LDIMT1)
      COMMON /SSPAR2/ NSSKIP
      COMMON /SSPAR3/ IFSKIP, IFMODP, IFSSVT, IFSTST(LDIMT1)
     $              ,                 IFEXVT, IFEXTR(LDIMT1)
      LOGICAL         IFSKIP, IFMODP, IFSSVT, IFSTST
     $              ,                 IFEXVT, IFEXTR
      COMMON /SSNORM/ DVNNH1, DVNNSM, DVNNL2, DVNNL8
     $              , DVDFH1, DVDFSM, DVDFL2, DVDFL8
     $              , DVPRH1, DVPRSM, DVPRL2, DVPRL8
# 12 "TOTAL" 2
# 12 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TOPOL" 1
C     
C     Arrays for direct stiffness summation
C     
# 4
      COMMON /CFACES/ NOMLIS(2,3),NMLINV(6),GROUP(6),SKPDAT(6,6)
     $               ,EFACE(6),EFACE1(6)
c     
      INTEGER NOMLIS,NMLINV,GROUP,SKPDAT,EFACE,EFACE1
      COMMON /CEDGES/ ESKIP(-12:12,3),NEDG(3)    ,NCMP
     $               ,IXCN(8),NOFFST(3,0:LDIMT1)
     $               ,MAXMLT,NSPMAX(0:LDIMT1)
     $               ,NGSPCN(0:LDIMT1),NGSPED(3,0:LDIMT1)
     $               ,NUMSCN(LELT,0:LDIMT1),NUMSED(LELT,0:LDIMT1)
     $               ,GCNNUM( 8,LELT,0:LDIMT1),LCNNUM( 8,LELT,0:LDIMT1)
     $               ,GEDNUM(12,LELT,0:LDIMT1),LEDNUM(12,LELT,0:LDIMT1)
     $               ,GEDTYP(12,LELT,0:LDIMT1)
     $               ,NGCOMM(2,0:LDIMT1)
      INTEGER ESKIP,NEDG,IXCN,MAXMLT,NSPMAX,NOFFST,NGSPCN,NGSPED
     $       ,NUMSCN,NUMSED,GCNNUM,LCNNUM,GEDNUM,LEDNUM,GEDTYP
     $       ,NGCOMM
      COMMON /EDGES/ IEDGE(20),IEDGEF(2,4,6,0:1)
     $              ,ICEDG(3,16),IEDGFC(4,6),ICFACE(4,10)
     $              ,INDX(8),INVEDG(27)
      
# 13 "TOTAL" 2
# 13 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 14 "TOTAL" 2
# 14 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TURBO" 1
C     
C       Common block for turbulence model
C     
# 4
      COMMON /TURBR/ VTURB (LX1M,LY1M,LZ1M,LELV)
     $             , TURBL (LX1M,LY1M,LZ1M,LELV)
     $             , UWALL (LX1M,LZ1M,6,LELV)
     $             , ZWALL (LX1M,LZ1M,6,LELV)
     $             , TWX   (LX1M,LZ1M,6,LELV)
     $             , TWY   (LX1M,LZ1M,6,LELV)
     $             , TWZ   (LX1M,LZ1M,6,LELV)
      COMMON /TURBC/ CMU,CMT,SGK,SGE,CE1,CE2,VKC,BTA,SGT
     $             , BETA1,BETA2
     $             , CMI,SKI,SEI,VKI,BTI,STI
     $             , ZPLDAT,ZPUDAT,ZPVDAT,TLMAX,TLIMUL
      COMMON /TURBI/ IFLDK,IFLDTK,IFLDE,IFLDTE
      COMMON /TURBL/ IFSWALL,IFTWSH(6,LELV),IFCWUZ
C     
      
      LOGICAL IFSWALL,IFTWSH,IFCWUZ
# 15 "TOTAL" 2
# 15 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/ESOLV" 1
# 1
      common /econst/ iesolv
      common /efastm/ ifalgn(lelv), ifrsxy(lelv)
      logical         ifalgn, ifrsxy
      common /eouter/ volel(lelv) 
# 16 "TOTAL" 2
# 16 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZ" 1
C     
C     Gauss-Labotto and Gauss points
C     
# 4
      COMMON /GAUSS/ ZGM1(LX1,3), ZGM2(LX2,3), ZGM3(LX3,3)
     $              ,ZAM1(LX1)  , ZAM2(LX2)  , ZAM3(LX3)
C     
C    Weights
C     
      COMMON /WXYZ/ WXM1(LX1), WYM1(LY1), WZM1(LZ1), W3M1(LX1,LY1,LZ1)
     $             ,WXM2(LX2), WYM2(LY2), WZM2(LZ2), W3M2(LX2,LY2,LZ2)
     $             ,WXM3(LX3), WYM3(LY3), WZM3(LZ3), W3M3(LX3,LY3,LZ3)
     $             ,WAM1(LY1), WAM2(LY2), WAM3(LY3)
     $             ,W2AM1(LX1,LY1), W2CM1(LX1,LY1)
     $             ,W2AM2(LX2,LY2), W2CM2(LX2,LY2)
     $             ,W2AM3(LX3,LY3), W2CM3(LX3,LY3)
# 17 "TOTAL" 2
# 17 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/WZF" 1
c     
c Points (z) and weights (w) on velocity, pressure
c     
c     zgl -- velocity points on Gauss-Lobatto points i = 1,...nx
c     zgp -- pressure points on Gauss         points i = 1,...nxp (nxp =
c     
c     parameter (lxm = lx1)
# 8
      parameter (lxq = lx2)
c     
      common /wz1/   zgl(lx1),wgl(lx1)
     $           ,   zgp(lx1),wgp(lxq)
c     
c     Tensor- (outer-) product of 1D weights   (for volumetric integrati
c     
      common /wz2/  wgl1(lx1*lx1),wgl2(lxq*lxq)
     $           ,  wgli(lx1*lx1)
c     
c     
c    Frequently used derivative matrices:
c     
c    D1, D1t   ---  differentiate on mesh 1 (velocity mesh)
c    D2, D2t   ---  differentiate on mesh 2 (pressure mesh)
c     
c    DXd,DXdt  ---  differentiate from velocity mesh ONTO dealiased mesh
c                   (currently the same as D1 and D1t...)
c     
c     
      common /deriv/  d1    (lx1*lx1) , d1t    (lx1*lx1)
     $             ,  d2    (lx1*lx1) , b2p    (lx1*lx1)
     $             ,  B1iA1 (lx1*lx1) , B1iA1t (lx1*lx1)
     $             ,  da    (lx1*lx1) , dat    (lx1*lx1)
     $             ,  iggl  (lx1*lxq) , igglt  (lx1*lxq)
     $             ,  dglg  (lx1*lxq) , dglgt  (lx1*lxq)
     $             ,  wglg  (lx1*lxq) , wglgt  (lx1*lxq)
      real ixd,ixdt,iggl,igglt
c     
# 18 "TOTAL" 2
# 18 "TOTAL"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DSSUM" 1
# 1
      parameter (lds=lx1*ly1*lz1*lelt)
      common /newdss/ ids_lgl1(-1:lds),ids_lgl2(-1:lds),ids_ptr(lds)
# 2928 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2928 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 2929 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2929 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      character*3 name3
      
      write(6,*) mg_h1_lmax,ii,' ',name3,' CHKR'
      
      return
      end
c-----------------------------------------------------------------------
      subroutine outgmat(a,ng,nx,ny,name6,k,e)
      
      integer e
      real a(ng,nx,ny)
      common /ctmp0/ w(100000)
      character*6 name6
      
c     do i=1,ng
      do i=1,1
         sum = 0.
         do ii=1,nx*ny
            w(ii)=a(i,ii,1)
            sum = sum + a(i,ii,1)
         enddo
      
         write(6,1) name6,i,k,e,nx,ny,ng,sum
    1    format(a6,6i5,f12.5,'  outgmat')
      
         call outmatz(w,nx,ny,name6,i)
      enddo
      
      return
      end
c-----------------------------------------------------------------------
      subroutine outmatz(a,m,n,name6,ie)
      real a(m,n)
      character*6 name6
      
      sum=0.
      sua=0.
      do i=1,m*n
         sum=sum+    a(i,1)
         sua=sua+abs(a(i,1))
      enddo
      sum=sum/(m*n)
      sua=sua/(m*n)
      
      write(6,*) 
      write(6,1) ie,name6,m,n,sum,sua
    1 format(i8,' matrix: ',a6,2i5,1p2e12.4)
      
      n12 = min(m,12)
      do j=m,1,-1
         write(6,6) ie,name6,(a(i,j),i=1,n12)
      enddo
    6 format(i3,1x,a6,12f9.5)
c     write(6,*) 
      return
      end
c-----------------------------------------------------------------------
      subroutine h1mg_setup_schwarz_wt_2(wt,ie,n,work,ifsqrt)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2988 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2988 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real wt(1),work(1)
      logical ifsqrt
      
      if (ndim.eq.2) call h1mg_setup_schwarz_wt2d_2(wt,ie,n,work,ifsqrt)
      if (ndim.eq.3) call h1mg_setup_schwarz_wt3d_2(wt,ie,n,work,ifsqrt)
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_schwarz_wt2d_2(wt,ie,n,work,ifsqrt)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 2999 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 2999 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      logical ifsqrt
      integer n
      real wt(n,4,2,nelv)
      real work(n,n)
      
      integer ie,i,j
      do j=1,n
         wt(j,1,1,ie)=1.0/work(1,j)
         wt(j,2,1,ie)=1.0/work(2,j)
         wt(j,3,1,ie)=1.0/work(n-1,j)
         wt(j,4,1,ie)=1.0/work(n,j)
      enddo
      do i=1,n
         wt(i,1,2,ie)=1.0/work(i,1)
         wt(i,2,2,ie)=1.0/work(i,2)
         wt(i,3,2,ie)=1.0/work(i,n-1)
         wt(i,4,2,ie)=1.0/work(i,n)
      enddo
      if(ifsqrt) then
         do ii=1,2
         do j=1,4
         do i=1,n
            wt(i,j,ii,ie)=sqrt(wt(i,j,ii,ie))
         enddo
         enddo
         enddo
      endif
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_schwarz_wt3d_2(wt,ie,n,work,ifsqrt)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3032 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3032 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      logical ifsqrt
      integer n
      real wt(n,n,4,3,nelv)
      real work(n,n,n)
      
      integer ie,i,j,k
      integer lbr,rbr,lbs,rbs,lbt,rbt
      
      ierr = 0
      do k=1,n
      do j=1,n
         wt(j,k,1,1,ie)=1.0/work(1,j,k)
         wt(j,k,2,1,ie)=1.0/work(2,j,k)
         wt(j,k,3,1,ie)=1.0/work(n-1,j,k)
         wt(j,k,4,1,ie)=1.0/work(n,j,k)
      enddo
      enddo
      do k=1,n
      do i=1,n
         wt(i,k,1,2,ie)=1.0/work(i,1,k)
         wt(i,k,2,2,ie)=1.0/work(i,2,k)
         wt(i,k,3,2,ie)=1.0/work(i,n-1,k)
         wt(i,k,4,2,ie)=1.0/work(i,n,k)
      enddo
      enddo
      do j=1,n
      do i=1,n
         wt(i,j,1,3,ie)=1.0/work(i,j,1)
         wt(i,j,2,3,ie)=1.0/work(i,j,2)
         wt(i,j,3,3,ie)=1.0/work(i,j,n-1)
         wt(i,j,4,3,ie)=1.0/work(i,j,n)
      enddo
      enddo
      if(ifsqrt) then
         do ii=1,3
         do k=1,4
         do j=1,4
         do i=1,n
            wt(i,j,k,ii,ie)=sqrt(wt(i,j,k,ii,ie))
         enddo
         enddo
         enddo
         enddo
      endif
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_setup_schwarz_wt_1(wt,l,ifsqrt)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3082 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3082 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3083 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3083 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 3084 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3084 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3085 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3085 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real wt(1),work(1)
      logical ifsqrt
      
      integer enx,eny,enz,pm
      
      zero =  0
      one  =  1
      onem = -1
      
      n  = mg_h1_n (l,mg_fld)
      pm = p_mg_msk(l,mg_fld)
      
      enx=mg_nh(l)+2
      eny=mg_nh(l)+2
      enz=mg_nh(l)+2
      if(.not.if3d) enz=1
      ns = enx*eny*enz*nelfld(ifield)
      i  = ns+1
      
      call rone(mg_work(i),ns)
      
c     Sum overlap region (border excluded)
      call hsmg_extrude(mg_work,0,zero,mg_work(i),0,one ,enx,eny,enz)
      call hsmg_schwarz_dssum(mg_work(i),l)
      call hsmg_extrude(mg_work(i),0,one ,mg_work,0,onem,enx,eny,enz)
      call hsmg_extrude(mg_work(i),2,one,mg_work(i),0,one,enx,eny,enz)
      
      if(.not.if3d) then ! Go back to regular size array
         call hsmg_schwarz_toreg2d(mg_work,mg_work(i),mg_nh(l))
      else
         call hsmg_schwarz_toreg3d(mg_work,mg_work(i),mg_nh(l))
      endif
      
      call hsmg_dssum(mg_work,l)                           ! sum border 
      
      
      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nh(l)
      if (.not.if3d) nz=1
      nxyz = nx*ny*nz
      k    = 1
      do ie=1,nelfld(ifield)
c        call outmat(mg_work(k),nx,ny,'NEW WT',ie)
         call h1mg_setup_schwarz_wt_2(wt,ie,nx,mg_work(k),ifsqrt)
         k = k+nxyz
      enddo
c     stop
      
      return
      end
c----------------------------------------------------------------------
      
C======================== OpenACC =====================

      
c ==== hsmg is not implemented
      
c----------------------------------------------------------------------
# 3145
      subroutine h1mg_setup_dssum_acc

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3147 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3147 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3148 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3148 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 3149 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3149 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3150 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3150 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter (lxyz=(lx1+2)*(ly1+2)*(lz1+2))
      common /c_is1/ glo_num(lxyz*lelt)
      common /ivrtx/ vertex ((2**ldim)*lelt)
      
      integer*8 glo_num
      integer vertex
      integer nx,ny,nz
      integer l,l2,n
      
      ncrnr = 2**ndim
      
      call get_vert
      
      do l=1,mg_lmax  ! set up direct stiffness summation for each level
         nx=mg_nh(l)
         ny=mg_nh(l)
         nz=mg_nhz(l)
         call setupds_hsmg_acc(l,mg_gsh_handle(l,mg_fld),nx,ny,nz
     $                ,        nelv,nelgv,vertex,glo_num)
      
         nx=nx+2
         ny=ny+2
         nz=nz+2
         if(.not.if3d) nz=1
         l2 = l+mg_lmax
         call setupds_hsmg_acc(l2,mg_gsh_schwarz_handle(l,mg_fld)
     $        ,                nx,ny,nz,nelv,nelgv,vertex,glo_num)
      enddo
      
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_dssum_acc(u,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3185 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3185 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3186 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3186 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 3187 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3187 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      if (ifsync) call nekgsync()

# 3190
      etime1=dnekclock()

c      call gs_op(mg_gsh_schwarz_handle(l,mg_fld),u,1,1,0)
      
# 3194
      call hsmg_dssum_acc(u,l+mg_lmax)
      

# 3197
      tdadd =tdadd + dnekclock()-etime1

# 3199
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_wt_acc(e,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3205 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3205 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3206 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3206 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3207 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3207 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      if(.not.if3d) call hsmg_schwarz_wt2d(
     $    e,mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),mg_nh(l))
      if(if3d) call hsmg_schwarz_wt3d_acc(
     $    e,mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),mg_nh(l))
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_wt3d_acc(e,wt,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3218 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3218 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real e(n,n,n,nelv)
      real wt(n,n,4,3,nelv)
      
      integer ie,i,j,k
      
!$ACC DATA PRESENT(e,wt)
!$ACC PARALLEL LOOP
      do ie=1,nelv
         do k=1,n
         do j=1,n
            e(1  ,j,k,ie)=e(1  ,j,k,ie)*wt(j,k,1,1,ie)
            e(2  ,j,k,ie)=e(2  ,j,k,ie)*wt(j,k,2,1,ie)
            e(n-1,j,k,ie)=e(n-1,j,k,ie)*wt(j,k,3,1,ie)
            e(n  ,j,k,ie)=e(n  ,j,k,ie)*wt(j,k,4,1,ie)
         enddo
         enddo
         do k=1,n
         do i=3,n-2
            e(i,1  ,k,ie)=e(i,1  ,k,ie)*wt(i,k,1,2,ie)
            e(i,2  ,k,ie)=e(i,2  ,k,ie)*wt(i,k,2,2,ie)
            e(i,n-1,k,ie)=e(i,n-1,k,ie)*wt(i,k,3,2,ie)
            e(i,n  ,k,ie)=e(i,n  ,k,ie)*wt(i,k,4,2,ie)
         enddo
         enddo
         do j=3,n-2
         do i=3,n-2
            e(i,j,1  ,ie)=e(i,j,1  ,ie)*wt(i,j,1,3,ie)
            e(i,j,2  ,ie)=e(i,j,2  ,ie)*wt(i,j,2,3,ie)
            e(i,j,n-1,ie)=e(i,j,n-1,ie)*wt(i,j,3,3,ie)
            e(i,j,n  ,ie)=e(i,j,n  ,ie)*wt(i,j,4,3,ie)
         enddo
         enddo
      enddo
!$ACC END PARALLEL LOOP
!$ACC END DATA
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_intp_acc(uf,uc,l) ! l is coarse level
      real uf(1),uc(1)
      integer l

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3262 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3262 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3263 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3263 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      call hsmg_tnsr_acc
     $     (uf,mg_nh(l+1),uc,mg_nh(l),mg_jh(1,l),mg_jht(1,l))
      
      return
      end
      
c----------------------------------------------------------------------
c     computes
c     v = [A (x) A] u      or
c     v = [A (x) A (x) A] u 
      subroutine hsmg_tnsr_acc(v,nv,u,nu,A,At)
      integer nv,nu
      real v(1),u(1),A(1),At(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3278 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3278 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3279 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3279 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      if (.not. if3d) then
         call hsmg_tnsr2d(v,nv,u,nu,A,At)
      else
c         call hsmg_tnsr3d(v,nv,u,nu,A,At,At)
         call hsmg_tnsr3d_acc(v,nv,u,nu,A,A,A)
      endif
      return
      end
      
c----------------------------------------------------------------------
c     computes
c              
c     v = [C (x) B (x) A] u
      subroutine hsmg_tnsr3d_acc(v,nv,u,nu,A,B,C)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3294 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3294 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer nv,nu,nu3,nv3
      
      real v(nv,nv,nv,nelv),u(nu,nu,nu,nelv)
      real A(nv,nu),B(nv,nu),C(nv,nu)
      
      parameter (lwk=(lx1+2)*(ly1+2)*(lz1+2))
c      common /hsmgw/ work(0:lwk-1),work2(0:lwk-1)
      common /hsmgw2/ work2(lx1+2,ly1+2,lz1+2,lelv)
     $     , work3(lx1+2,ly1+2,lz1+2,lelv)
      
      integer i,j,k,l,e
      
      nu3 = nu**3
      nv3 = nv**3
      
!$ACC DATA PRESENT(u,v,A,B,C,work2,work3)
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR
      do e=1,nelv
         do k = 1,nu
         do j = 1,nu
         do i = 1,nv
            work2(i,j,k,e) = 0.0
!$ACC LOOP SEQ
            do l = 1,nu
               work2(i,j,k,e) = work2(i,j,k,e)+
     $              A(i,l)*u(l,j,k,e)
            enddo            
         enddo
         enddo
         enddo
      enddo
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR
      do e=1,nelv
         do k = 1,nu
         do j = 1,nv
         do i = 1,nv
            work3(i,j,k,e) = 0.0
!$ACC LOOP SEQ
            do l = 1,nu
               work3(i,j,k,e) = work3(i,j,k,e)+
     $              B(j,l)*work2(i,l,k,e)
            enddo
         enddo
         enddo
         enddo
      enddo
      
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR
      do e=1,nelv
         do k = 1,nv
         do j = 1,nv
         do i = 1,nv
            v(i,j,k,e) = 0.0
!$ACC LOOP SEQ
            do l = 1,nu
               v(i,j,k,e) = v(i,j,k,e)+
     $              C(k,l)*work3(i,j,l,e)
            enddo
         enddo
         enddo
         enddo
      enddo
      
!$ACC END DATA
      
      return
      end
      
      
      
c----------------------------------------------------------------------
c     u = wt .* u
      subroutine hsmg_do_wt_acc(u,wt,nx,ny,nz)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3372 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3372 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3373 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3373 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer nx,ny,nz
      real u(nx,ny,nz,lelv)
      real wt(nx,nz,2,ndim,lelv)
      
      integer e
      
c     if (nx.eq.2) then
c        do e=1,nelv
c           call outmat(wt(1,1,1,1,e),nx,nz,'wt 1-1',e)
c           call outmat(wt(1,1,2,1,e),nx,nz,'wt 2-1',e)
c           call outmat(wt(1,1,1,2,e),nx,nz,'wt 1-2',e)
c           call outmat(wt(1,1,2,2,e),nx,nz,'wt 2-2',e)
c        enddo
c        call exitti('hsmg_do_wt quit$',nelv)
c     endif
      
      if (.not. if3d) then
         do ie=1,nelv
            do j=1,ny
               u( 1,j,1,ie)=u( 1,j,1,ie)*wt(j,1,1,1,ie)
               u(nx,j,1,ie)=u(nx,j,1,ie)*wt(j,1,2,1,ie)
            enddo
            do i=2,nx-1
               u(i, 1,1,ie)=u(i, 1,1,ie)*wt(i,1,1,2,ie)
               u(i,ny,1,ie)=u(i,ny,1,ie)*wt(i,1,2,2,ie)
            enddo
         enddo
      else
      
!$ACC DATA PRESENT(u,wt)
!$ACC PARALLEL LOOP 
         do ie=1,nelv
            do k=1,nz
            do j=1,ny
               u( 1,j,k,ie)=u( 1,j,k,ie)*wt(j,k,1,1,ie)
               u(nx,j,k,ie)=u(nx,j,k,ie)*wt(j,k,2,1,ie)
            enddo
            enddo
            do k=1,nz
            do i=2,nx-1
               u(i, 1,k,ie)=u(i, 1,k,ie)*wt(i,k,1,2,ie)
               u(i,ny,k,ie)=u(i,ny,k,ie)*wt(i,k,2,2,ie)
            enddo
            enddo
            do j=2,ny-1
            do i=2,nx-1
               u(i,j, 1,ie)=u(i,j, 1,ie)*wt(i,j,1,3,ie)
               u(i,j,nz,ie)=u(i,j,nz,ie)*wt(i,j,2,3,ie)
            enddo
            enddo
         enddo
!$ACC END PARALLEL LOOP
!$ACC END DATA
      endif
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_tnsr1_acc(v,nv,nu,A,At)
c     
c     v = [A (x) A] u      or
c     v = [A (x) A (x) A] u 
c     
      integer nv,nu
      real v(1),A(1),At(1)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3439 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3439 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3440 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3440 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      if (.not. if3d) then
         call hsmg_tnsr1_2d(v,nv,nu,A,At)
      else
         call hsmg_tnsr1_3d_acc(v,nv,nu,A,A,A)
      endif
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_tnsr1_3d_acc(v,nv,nu,A,B,C) ! v = [C (x) B (x) A] 

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3451 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3451 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      integer nv,nu
      real v(nu,nu,nu,lelv)
      real v2(nv,nv,nv,lelv)
      real A(nv,nu), B(nv,nu), C(nv,nu)
      parameter (lwk=(lx1+2)*(ly1+2)*(lz1+2))
c      common /hsmgw/ work(0:lwk-1),work2(0:lwk-1)
      
      common /hsmgw2/ work2(lx1+2,ly1+2,lz1+2,lelv)
     $     ,          work3(lx1+2,ly1+2,lz1+2,lelv)
      
      integer e,e0,ee,es
      integer i,j,k,l
      
      e0=1
      es=1
      ee=nelv
      
      if (nv.gt.nu) then
         write(*,*) "NV .gt. NU is not implemented"
         stop
         e0=nelv
         es=-1
         ee=1
      endif
      
      nu3 = nu**3
      nv3 = nv**3
      
      
!$ACC  DATA PRESENT(v,A,B,C,work2,work3)
!$ACC&      CREATE(v2)
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR
      do e=e0,ee,es
         do k = 1,nu
         do j = 1,nu
         do i = 1,nv
            work2(i,j,k,e) = 0.0
!$ACC LOOP SEQ
            do l = 1,nu
               work2(i,j,k,e) = work2(i,j,k,e)+
     $              A(i,l)*v(l,j,k,e)
            enddo            
         enddo
         enddo
         enddo
      enddo
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR 
      do e=e0,ee,es
         do k = 1,nu
         do j = 1,nv
         do i = 1,nv
            work3(i,j,k,e) = 0.0
!$ACC LOOP SEQ
            do l = 1,nu
               work3(i,j,k,e) = work3(i,j,k,e)+
     $              B(j,l)*work2(i,l,k,e)
            enddo
         enddo
         enddo
         enddo
      enddo
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR 
      do e=e0,ee,es
         do k = 1,nv
         do j = 1,nv
         do i = 1,nv
            v2(i,j,k,e) = 0.0
!$ACC LOOP SEQ  
            do l = 1,nu
               v2(i,j,k,e) = v2(i,j,k,e)+
     $              C(k,l)*work3(i,j,l,e)
            enddo
         enddo
         enddo
         enddo
      enddo
      
      call copy_acc(v,v2,nv3*lelv)
      
!$ACC END DATA
      
c      do e=e0,ee,es
c         iu = 1 + (e-1)*nu3
c         iv = 1 + (e-1)*nv3
c         call mxm(A,nv,v(iu),nu,work,nu*nu)
c         do i=0,nu-1
c            call mxm(work(nv*nu*i),nv,Bt,nu,work2(nv*nv*i),nv)
c         enddo
c         call mxm(work2,nv*nv,Ct,nu,v(iv),nv)
c      enddo
      
      return
      end
      
c------------------------------------------   T  -----------------------
      subroutine h1mg_rstr_acc(r,l,ifdssum) ! r =J r,   l is coarse leve

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3552 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3552 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3553 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3553 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      logical ifdssum
      
      real r(lx1*ly1*lz1*lelv)
      integer l
      
      call hsmg_do_wt_acc(r,mg_rstr_wt(mg_rstr_wt_index(l+1,mg_fld))
     $                     ,mg_nh(l+1),mg_nh(l+1),mg_nhz(l+1))
      
      call hsmg_tnsr1_acc(r,mg_nh(l),mg_nh(l+1),mg_jht(1,l),mg_jh(1,l))
      
      if (ifdssum) then
         call hsmg_dssum_acc(r,l)
      endif
      
      return
      end
      
      
c----------------------------------------------------------------------
c     clobbers r
      subroutine hsmg_fdm_acc(e,r,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3575 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3575 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3576 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3576 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3577 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3577 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      call hsmg_do_fast_acc(e,r,
     $      mg_fast_s(mg_fast_s_index(l,mg_fld)),
     $      mg_fast_d(mg_fast_d_index(l,mg_fld)),
     $      mg_nh(l)+2)
      return
      end
c----------------------------------------------------------------------
c     clobbers r
      subroutine hsmg_do_fast_acc(e,r,s,d,nl)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3587 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3587 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3588 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3588 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      real e(nl,nl,nl,nelv)
      real r(nl,nl,nl,nelv)
      real s(nl,nl,2,ndim,nelv)
      real d(nl,nl,nl,nelv)
      
      real work(nl,nl,nl,nelv)
      real work2(nl,nl,nl,nelv)
      
      integer ie,nn,i
      integer ii,jj,kk,ee,ll
      nn=nl**ndim
      if(.not.if3d) then
         do ie=1,nelv
            call hsmg_tnsr2d_el(e(1,ie),nl,r(1,ie),nl
     $                         ,s(1,2,1,ie),s(1,1,2,ie))
            do i=1,nn
               r(i,ie)=d(i,ie)*e(i,ie)
            enddo
            call hsmg_tnsr2d_el(e(1,ie),nl,r(1,ie),nl
     $                         ,s(1,1,1,ie),s(1,2,2,ie))
         enddo
      else
      
c 1   
      
!$ACC  DATA PRESENT (e,r,s,d)
!$ACC&      CREATE(work,work2)
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR     
         do ie=1,nelv
            do kk = 1,nl
            do jj = 1,nl
            do ii = 1,nl
               work(ii,jj,kk,ie) = 0.0
!$ACC LOOP SEQ
               do ll = 1,nl
                  work(ii,jj,kk,ie) = work(ii,jj,kk,ie)+
     $                 s(ii,ll,2,1,ie)*r(ll,jj,kk,ie)
               enddo
            enddo
            enddo
            enddo
         enddo
         
c 2   
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR     
         do ie=1,nelv
            do kk = 1,nl
            do jj = 1,nl
            do ii = 1,nl
               work2(ii,jj,kk,ie) = 0.0
!$ACC LOOP SEQ
               do ll = 1,nl
                  work2(ii,jj,kk,ie) = work2(ii,jj,kk,ie)+
     $                 s(jj,ll,2,2,ie)*work (ii,ll,kk,ie)
               enddo
            enddo
            enddo
            enddo
         enddo
c 3   
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR     
         do ie=1,nelv
            do kk = 1,nl
            do jj = 1,nl
            do ii = 1,nl
               e(ii,jj,kk,ie) = 0.0
!$ACC LOOP SEQ
               do ll = 1,nl
                  e(ii,jj,kk,ie) = e(ii,jj,kk,ie)+
     $                 s(kk,ll,2,3,ie)*work2(ii,jj,ll,ie)
               enddo
               r(ii,jj,kk,ie) = d(ii,jj,kk,ie)*e(ii,jj,kk,ie)
            enddo
            enddo
            enddo
         enddo
c 4   
      
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR     
         do ie=1,nelv
            do kk = 1,nl
            do jj = 1,nl
            do ii = 1,nl
               work(ii,jj,kk,ie) = 0.0
!$ACC LOOP SEQ
               do ll = 1,nl
                  work(ii,jj,kk,ie) = work(ii,jj,kk,ie)+
     $                 s(ii,ll,1,1,ie)*r(ll,jj,kk,ie)
               enddo
            enddo
            enddo
            enddo
         enddo
c 5   
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR     
         do ie=1,nelv
            do kk = 1,nl
            do jj = 1,nl
            do ii = 1,nl
               work2(ii,jj,kk,ie) = 0.0
!$ACC LOOP SEQ
               do ll = 1,nl
                  work2(ii,jj,kk,ie) = work2(ii,jj,kk,ie)+
     $                 s(jj,ll,1,2,ie)*work(ii,ll,kk,ie)
               enddo
            enddo
            enddo
            enddo
         enddo
c 6   
!$ACC PARALLEL LOOP COLLAPSE(4) WORKER GANG VECTOR     
         do ie=1,nelv
            do kk = 1,nl
            do jj = 1,nl
            do ii = 1,nl
               e(ii,jj,kk,ie) = 0.0
!$ACC LOOP SEQ
               do ll = 1,nl
                  e(ii,jj,kk,ie) = e(ii,jj,kk,ie)+
     $                 s(kk,ll,1,3,ie)*work2(ii,jj,ll,ie)
               enddo
            enddo
            enddo
            enddo
         enddo
!$ACC END DATA
            
c            call hsmg_tnsr3d_el(e(1,ie),nl,r(1,ie),nl
c     $                         ,s(1,2,1,ie),s(1,1,2,ie),s(1,1,3,ie))
c            do i=1,nn
c               r(i,ie)=d(i,ie)*e(i,ie)
c            enddo
c            call hsmg_tnsr3d_el(e(1,ie),nl,r(1,ie),nl
c     $                         ,s(1,1,1,ie),s(1,2,2,ie),s(1,2,3,ie))
      endif
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_extrude_acc(arr1,l1,f1,arr2,l2,f2,nx,ny,nz)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3730 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3730 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3731 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3731 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer l1,l2,nx,ny,nz
      real arr1(nx,ny,nz,nelv),arr2(nx,ny,nz,nelv)
      real f1,f2
      
      integer i,j,k,ie,i0,i1
      i0=2
      i1=nx-1
      
      if(.not.if3d) then
         do ie=1,nelv
            do j=i0,i1
               arr1(l1+1 ,j,1,ie) = f1*arr1(l1+1 ,j,1,ie)
     $                             +f2*arr2(l2+1 ,j,1,ie)
               arr1(nx-l1,j,1,ie) = f1*arr1(nx-l1,j,1,ie)
     $                             +f2*arr2(nx-l2,j,1,ie)
            enddo
            do i=i0,i1
               arr1(i,l1+1 ,1,ie) = f1*arr1(i,l1+1 ,1,ie)
     $                             +f2*arr2(i,l2+1 ,1,ie)
               arr1(i,ny-l1,1,ie) = f1*arr1(i,ny-l1,1,ie)
     $                             +f2*arr2(i,nx-l2,1,ie)
            enddo
         enddo
      else
      
!$ACC DATA PRESENT(arr1,arr2)      
!$ACC PARALLEL LOOP 
         do ie=1,nelv
            do k=i0,i1
            do j=i0,i1
               arr1(l1+1 ,j,k,ie) = f1*arr1(l1+1 ,j,k,ie)
     $                             +f2*arr2(l2+1 ,j,k,ie)
               arr1(nx-l1,j,k,ie) = f1*arr1(nx-l1,j,k,ie)
     $                             +f2*arr2(nx-l2,j,k,ie)
            enddo
            enddo
            do k=i0,i1
            do i=i0,i1
               arr1(i,l1+1 ,k,ie) = f1*arr1(i,l1+1 ,k,ie)
     $                             +f2*arr2(i,l2+1 ,k,ie)
               arr1(i,nx-l1,k,ie) = f1*arr1(i,nx-l1,k,ie)
     $                             +f2*arr2(i,nx-l2,k,ie)
            enddo
            enddo
            do j=i0,i1
            do i=i0,i1
               arr1(i,j,l1+1 ,ie) = f1*arr1(i,j,l1+1 ,ie)
     $                             +f2*arr2(i,j,l2+1 ,ie)
               arr1(i,j,nx-l1,ie) = f1*arr1(i,j,nx-l1,ie)
     $                             +f2*arr2(i,j,nx-l2,ie)
            enddo
            enddo
         enddo
!$ACC END PARALLEL LOOP
!$ACC END DATA
      endif
      
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_toreg3d_acc(b,a,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3794 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3794 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real a(0:n+1,0:n+1,0:n+1,nelv),b(n,n,n,nelv)
      
      integer i,j,k,ie
      
!$ACC DATA PRESENT(a(0:n+1,0:n+1,0:n+1,1:nelv))
!$ACC&     PRESENT(b(1:n,1:n,1:n,1:nelv))
!$ACC PARALLEL LOOP
      do ie=1,nelv
      do k=1,n
      do j=1,n
      do i=1,n
         b(i,j,k,ie)=a(i,j,k,ie)
      enddo
      enddo
      enddo
      enddo
!$ACC END PARALLEL LOOP
!$ACC END DATA
      return
      end
      
      
c----------------------------------------------------------------------
      subroutine hsmg_schwarz_toext3d_acc(a,b,n)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3820 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3820 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      integer n
      real a(0:n+1,0:n+1,0:n+1,nelv),b(n,n,n,nelv)
      
      integer i,j,k,ie
      
!$ACC DATA PRESENT(a,b)
      
      call rzero_acc(a,(n+2)*(n+2)*(n+2)*nelv)
      
!$ACC PARALLEL LOOP
      do ie=1,nelv
      do k=1,n
      do j=1,n
      do i=1,n
         a(i,j,k,ie)=b(i,j,k,ie)
      enddo
      enddo
      enddo
      enddo
!$ACC END PARALLEL LOOP
!$ACC END DATA
      
      return
      end
      
c-----------------------------------------------------------------------
      subroutine h1mg_mask_acc(w,mask,nel)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3848 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3848 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
c      real    w   (lx1*ly1*lz1*lelv)
c      integer mask(lx1*ly1*lz1*lelv)   ! Pointer to Dirichlet BCs
      real    w   (1)
      integer mask(1)   ! Pointer to Dirichlet BCs
      
      integer e, i, n
      
!$ACC DATA PRESENT(w,mask)
!$ACC PARALLEL LOOP 
      do e=1,nel
         im = mask(e)
         n = mask(im)
         do i = im+1,im+n
            w(mask(i)) = 0.
         enddo
c         call mg_mask_e_acc(w,mask(im)) ! Zero out Dirichlet conditions
      enddo
!$ACC END PARALLEL LOOP
!$ACC END DATA
      return
      end
      
c----------------------------------------------------------------------
      subroutine h1mg_schwarz_acc(e,r,sigma,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3874 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3874 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3875 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3875 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real e(1),r(1)
      
      n = mg_h1_n(l,mg_fld)
      
      call h1mg_schwarz_part1_acc (e,r,l)
      call hsmg_schwarz_wt_acc    (e,l)          ! e  := W e
      call cmult_acc              (e,sigma,n)    !  l       l
      
      return
      end
c----------------------------------------------------------------------
      subroutine h1mg_schwarz_part1_acc (e,r,l)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3889 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3889 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3890 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3890 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 3891 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3891 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3892 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3892 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      real e(lx1*ly1*lz1*lelv),r(lx1*ly1*lz1*lelv)
      
      integer enx,eny,enz,pm
      
      zero =  0
      one  =  1
      onem = -1
      
      n  = mg_h1_n (l,mg_fld)
      pm = p_mg_msk(l,mg_fld)
      
      call h1mg_mask_acc  (r,mg_imask(pm),nelfld(ifield))  ! Zero Dirich
      
      if (if3d) then ! extended array 
         call hsmg_schwarz_toext3d_acc(mg_work,r,mg_nh(l))
      else
         write(*,*) "if2d = .false. is not impelmented"
         stop
         call hsmg_schwarz_toext2d(mg_work,r,mg_nh(l))
      endif
      
      enx=mg_nh(l)+2
      eny=mg_nh(l)+2
      enz=mg_nh(l)+2
      if(.not.if3d) enz=1
      i = enx*eny*enz*nelv+1
      
c     exchange interior nodes
      call hsmg_extrude_acc(mg_work,0,zero,mg_work,2,one,enx,eny,enz)
      
      call hsmg_schwarz_dssum_acc(mg_work,l)
      
      call hsmg_extrude_acc(mg_work,0,one ,mg_work,2,onem,enx,eny,enz)
      
      call hsmg_fdm_acc(mg_work(i),mg_work,l) ! Do the local solves
      
c     Sum overlap region (border excluded)
      call hsmg_extrude_acc
     $     (mg_work,0,zero,mg_work(i),0,one ,enx,eny,enz)
      
      call hsmg_schwarz_dssum_acc(mg_work(i),l)
      
      call hsmg_extrude_acc
     $     (mg_work(i),0,one ,mg_work,0,onem,enx,eny,enz)
      call hsmg_extrude_acc
     $     (mg_work(i),2,one,mg_work(i),0,one,enx,eny,enz)
      
      if(.not.if3d) then ! Go back to regular size array
         call hsmg_schwarz_toreg2d(e,mg_work(i),mg_nh(l))
      else
         call hsmg_schwarz_toreg3d_acc(e,mg_work(i),mg_nh(l))
      endif
      
      call hsmg_dssum_acc(e,l)                    ! sum border nodes
      
      call h1mg_mask_acc (e,mg_imask(pm),nelfld(ifield)) ! apply mask 
      
      return
      end
      
c----------------------------------------------------------------------
      subroutine hsmg_coarse_solve_acc(e,r)

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 3956 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3956 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/DOMAIN" 1
c     
c     arrays for overlapping Schwartz algorithm
c     
# 4
      parameter (ltotd = lx1*ly1*lz1*lelt                     )
c     
      common /ddptri/ ndom,n_o,nel_proc,gs_hnd_overlap
     $              , na (lelt+1) , ma(lelt+1)
     $              , nza(lelt+1)
c     
      integer gs_hnd_overlap
c     
c     These are the H1 coarse-grid arrays:
c     
      parameter(lxc=2)
      parameter(lcr=lxc**ldim)
      common /h1_crsi/ se_to_gcrs(lcr,lelt)
     $               , n_crs,m_crs, nx_crs, nxyz_c
      integer*8 se_to_gcrs
c     
      common /h1_crs/  h1_basis(lx1*lxc),h1_basist(lxc*lx1)
     $               , h1_basis_acc(lx1,lxc),h1_basist_acc(lxc,lx1)
c     
      real             l2_basis(lx2*lxc),l2_basist(lxc*lx2)
      equivalence     (h1_basis  ,l2_basis  )
      equivalence     (h1_basist ,l2_basist )
c     
      real             l2_basis_acc(lx2,lxc),l2_basist_acc(lxc,lx2)
C      equivalence     (h1_basis_acc ,l2_basis_acc  )
C      equivalence     (h1_basist_acc ,l2_basist_acc )
# 3957 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3957 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/ESOLV" 1
# 1
      common /econst/ iesolv
      common /efastm/ ifalgn(lelv), ifrsxy(lelv)
      logical         ifalgn, ifrsxy
      common /eouter/ volel(lelv) 
# 3958 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3958 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 3959 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3959 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 3960 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3960 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 3961 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3961 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 3962 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3962 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 3963 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3963 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 3964 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3964 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 3965 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 3965 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      parameter (lt=lx1*ly1*lz1*lelt)
      
      real e(lt),r(lt)
c     
      integer n_crs_tot
      save    n_crs_tot
      data    n_crs_tot /0/
c     
      if (icalld.eq.0) then ! timer info
         ncrsl=0
         tcrsl=0.0
      endif
      icalld = 1
      
      if (ifsync) call nekgsync()
      
      ncrsl  = ncrsl  + 1

# 3983
      etime1=dnekclock()

      
# 3986
      call crs_solve(xxth(ifield),e,r)
      

# 3989
      tcrsl=tcrsl+dnekclock()-etime1

      
# 3992
      return
      end
      
      
c-----------------------------------------------------------------------
      subroutine h1mg_solve_acc(z,rhs,if_hybrid)  !  Solve preconditione
      
c     Assumes that preprocessing has been completed via h1mg_setup()
      
      

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 4003 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4003 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/HSMG" 1
      
c     Allocate MHD memory only if lbx1==lx1
# 3
      parameter (lmg_mhd=1-(lx1-lbx1)/(lx1-1))!1 if MHD is true, 0 other
      
      parameter (lmgs=1 + lmg_mhd)         ! max number of multigrid sol
      parameter (lmgn=3)                   ! max number of multigrid lev
      parameter (lmgx=lmgn+1)              ! max number of mg index leve
      parameter (lxm=lx2+2,lym=lxm,lzm=lz2+2*(ldim-2)) ! mgrid sizes
      parameter (lmg_rwt=2*lxm*lzm)        ! restriction weight max size
      parameter (lmg_fasts=2*lxm*lxm)      ! FDM S max size
      parameter (lmg_fastd=2*lxm*lym*lzm)  ! FDM D max size
      parameter (lmg_swt=2*lxm*lzm)        ! schwarz weight max size
      parameter (lmg_g=2*lx2*ly2*lz2)      ! metrics max size
      parameter (lmg_solve=2*lxm*lym*lzm)  ! solver r,e max size
c     
      common /mghs/ mg_lmax                     !number of multigrid lev
     $            , mg_nx(lmgn)                 !level poly. order (for 
     $            , mg_ny(lmgn), mg_nz (lmgn)
     $            , mg_nh(lmgn), mg_nhz(lmgn)   !number of 1d nodes
     $            , mg_gsh_schwarz_handle(lmgn,lmgs) !dssum schwarz hand
     $            , mg_gsh_handle        (lmgn,lmgs) !dssum handle
     $            , mg_rstr_wt_index     (lmgx,0:lmgs)
     $            , mg_mask_index        (lmgx,0:lmgs)
     $            , mg_solve_index       (lmgx,0:lmgs)
     $            , mg_fast_s_index      (lmgx,0:lmgs)
     $            , mg_fast_d_index      (lmgx,0:lmgs)
     $            , mg_schwarz_wt_index  (lmgx,0:lmgs)
     $            , mg_g_index           (lmgx,0:lmgs)
     $            , mg_fld                           !active mg field
c     
      integer mg_lmax,mg_nx,mg_ny,mg_nz,mg_nh
      integer mg_gsh_handle
      integer mg_rstr_wt_index, mg_mask_index
      integer mg_fast_s_index, mg_fast_d_index
      integer mg_gsh_schwarz_handle
      integer mg_solve_index
c     
      common /mghr/ mg_jh(lxm*lxm,lmgn)      !c-to-f interpolation matri
     $            , mg_jht(lxm*lxm,lmgn)     !transpose of mg_jh
     $            , mg_jhfc (lxm*lxm,lmgn)   !f-to-c interpolation
     $            , mg_jhfct(lxm*lxm,lmgn)   !transpose of mg_jhfc
     $            , mg_ah(lxm*lxm,lmgn)      !A hat matrices
     $            , mg_bh(lxm,lmgn)          !B hat matrices
     $            , mg_dh(lxm*lxm,lmgn)      !D hat matrices
     $            , mg_dht(lxm*lxm,lmgn)     !D hat transpose matrices
     $            , mg_zh(lxm,lmgn)          !Nodal coordinates
c     
     $            , mg_rstr_wt   (0:lmgs*lmg_rwt*2*ldim*lelt-1) !restric
     $            , mg_mask      (0:lmgs*lmg_rwt*4*ldim*lelt-1)   !b.c. 
     $            , mg_fast_s    (0:lmgs*lmg_fasts*2*ldim*lelt-1)
     $            , mg_fast_d    (0:lmgs*lmg_fastd*lelt-1)
     $            , mg_schwarz_wt(0:lmgs*lmg_swt*4*ldim*lelt-1)
     $            , mg_solve_e   (0:lmg_solve*lelt-1)
     $            , mg_solve_r   (0:lmg_solve*lelt-1)
c     
     $            , mg_h1        (0:lmg_g*lelt-1)
     $            , mg_h2        (0:lmg_g*lelt-1)
     $            , mg_b         (0:lmg_g*lelt-1)
     $            , mg_g         (0:lmg_g*((ldim-1)*3)*lelt-1) !metrics 
c     
     $            , mg_work      (2*lxm*lym*lzm*lelt) ! must be able to 
     $            , mg_work2     (lxm*lym*lzm*lelt)   ! two lower level 
     $            , mg_worke     (lxm*lym*lzm,6)      ! schwarz arrays
      
      real mg_jh,mg_jht,mg_ah,mg_bh,mg_dh,mg_dht,mg_zh
      real mg_jhfc,mg_jhfct
      real mg_rstr_wt, mg_mask
      real mg_fast_s, mg_fast_d
      real mg_schwarz_wt
      real mg_solve_e,mg_solve_r
      real mg_h1,mg_h2,mg_b,mg_g
      real mg_work,mg_work2,mg_worke
      
      integer mg_imask(0:lmgs*lmg_rwt*4*ldim*lelt-1) ! For h1mg, mask is
      equivalence(mg_imask,mg_mask)
      
      
c     Specific to h1 multigrid:
      
      common /mgh1i/ mg_h1_lmax
     $             , mg_h1_n  (lmgx,ldimt1)
     $             , p_mg_h1  (lmgx,ldimt1),p_mg_h2(lmgx,ldimt1)
     $             , p_mg_b   (lmgx,ldimt1),p_mg_g (lmgx,ldimt1)
     $             , p_mg_msk (lmgx,ldimt1)
      
      integer mg_h1_n
      integer p_mg_h1,p_mg_h2,p_mg_b,p_mg_g,p_mg_msk
# 4004 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4004 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/GEOM" 1
C     
C     Geometry arrays
C     
# 4
      COMMON /GXYZ/
     $              XM1   (LX1,LY1,LZ1,LELT)
     $             ,YM1   (LX1,LY1,LZ1,LELT)
     $             ,ZM1   (LX1,LY1,LZ1,LELT)
     $             ,XM2   (LX2,LY2,LZ2,LELV)
     $             ,YM2   (LX2,LY2,LZ2,LELV)
     $             ,ZM2   (LX2,LY2,LZ2,LELV)
C     
      COMMON /GISO1/
     $              RXM1  (LX1,LY1,LZ1,LELT)
     $             ,SXM1  (LX1,LY1,LZ1,LELT)
     $             ,TXM1  (LX1,LY1,LZ1,LELT)
     $             ,RYM1  (LX1,LY1,LZ1,LELT)
     $             ,SYM1  (LX1,LY1,LZ1,LELT)
     $             ,TYM1  (LX1,LY1,LZ1,LELT)
     $             ,RZM1  (LX1,LY1,LZ1,LELT)
     $             ,SZM1  (LX1,LY1,LZ1,LELT)
     $             ,TZM1  (LX1,LY1,LZ1,LELT)
     $             ,JACM1 (LX1,LY1,LZ1,LELT)
     $             ,jacmi (lx1*ly1*lz1,lelt)
      real          jacm1,jacmi
C     
      COMMON /GISO2/
     $              RXM2  (LX2,LY2,LZ2,LELV)
     $             ,SXM2  (LX2,LY2,LZ2,LELV)
     $             ,TXM2  (LX2,LY2,LZ2,LELV)
     $             ,RYM2  (LX2,LY2,LZ2,LELV)
     $             ,SYM2  (LX2,LY2,LZ2,LELV)
     $             ,TYM2  (LX2,LY2,LZ2,LELV)
     $             ,RZM2  (LX2,LY2,LZ2,LELV)
     $             ,SZM2  (LX2,LY2,LZ2,LELV)
     $             ,TZM2  (LX2,LY2,LZ2,LELV)
     $             ,JACM2 (LX2,LY2,LZ2,LELV)
      REAL          JACM2
c     
      common /gisod/ rx(lxd*lyd*lzd,ldim*ldim,lelv)
c     
      COMMON /GMFACT/
     $              G1M1  (LX1,LY1,LZ1,LELT)
     $             ,G2M1  (LX1,LY1,LZ1,LELT)
     $             ,G3M1  (LX1,LY1,LZ1,LELT)
     $             ,G4M1  (LX1,LY1,LZ1,LELT)
     $             ,G5M1  (LX1,LY1,LZ1,LELT)
     $             ,G6M1  (LX1,LY1,LZ1,LELT)
C     
      COMMON /GSURF/
     $              UNX   (LX1,LZ1,6,LELT)
     $             ,UNY   (LX1,LZ1,6,LELT)
     $             ,UNZ   (LX1,LZ1,6,LELT)
     $             ,T1X   (LX1,LZ1,6,LELT)
     $             ,T1Y   (LX1,LZ1,6,LELT)
     $             ,T1Z   (LX1,LZ1,6,LELT)
     $             ,T2X   (LX1,LZ1,6,LELT)
     $             ,T2Y   (LX1,LZ1,6,LELT)
     $             ,T2Z   (LX1,LZ1,6,LELT)
     $             ,AREA  (LX1,LZ1,6,LELT)
     $             ,DLAM
      COMMON /GVOLM/
     $              VNX   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNY   (LX1M,LY1M,LZ1M,LELT)
     $             ,VNZ   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V1Z   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2X   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Y   (LX1M,LY1M,LZ1M,LELT)
     $             ,V2Z   (LX1M,LY1M,LZ1M,LELT)
C     
      COMMON /GLOG/
     $        IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER(LELT),IFQINP(6,LELV),IFEPPM(6,LELV)
     $       ,IFLMSF(0:1),IFLMSE(0:1),IFLMSC(0:1)
     $       ,IFMSFC(6,LELT,0:1)
     $       ,IFMSEG(12,LELT,0:1)
     $       ,IFMSCR(8,LELT,0:1)
     $       ,IFNSKP(8,LELT)
     $       ,IFBCOR
      LOGICAL IFGEOM,IFGMSH3,IFVCOR,IFSURT,IFMELT,IFWCNO
     $       ,IFRZER,IFQINP,IFEPPM
     $       ,IFLMSF,IFLMSE,IFLMSC,IFMSFC
     $       ,IFMSEG,IFMSCR,IFNSKP
     $       ,IFBCOR
C     
# 4005 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4005 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 4006 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4006 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/MASS" 1
# 1
      COMMON /MASS/
     $       BM1   (LX1,LY1,LZ1,LELT),  BM2   (LX2,LY2,LZ2,LELV)
     $      ,BINVM1(LX1,LY1,LZ1,LELV),  BINTM1(LX1,LY1,LZ1,LELT)
     $      ,BM2INV(LX2,LY2,LZ2,LELT),  BAXM1 (LX1,LY1,LZ1,LELT)
     $      ,BM1LAG(LX1,LY1,LZ1,LELT,LORDER-1)
     $      ,VOLVM1,VOLVM2,VOLTM1,VOLTM2
     $      ,YINVM1(LX1,LY1,LZ1,LELT)
# 4007 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4007 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/SOLN" 1
# 1
      parameter (lvt1  = lx1*ly1*lz1*lelv)
      parameter (lvt2  = lx2*ly2*lz2*lelv)
      parameter (lbt1  = lbx1*lby1*lbz1*lbelv)
      parameter (lbt2  = lbx2*lby2*lbz2*lbelv)
      
      parameter (lptmsk = lvt1*(5+2*ldimt) + 4*lbt1)
      parameter (lptsol
     $         = lvt1*(12 + 4*ldimt + 2*ldimt1 + (3+ldimt)*(lorder-1))
     $         + lvt2*(lorder-1)
     $         + lbt1*(12 + 3*(lorder-1))
     $         + lbt2*(lorder-1) )
c    $         + lptmsk )
      
      parameter (lorder2 = max(1,lorder-2) )
C     
C     Solution and data
C     
      COMMON /BQCB/    BQ     (LX1,LY1,LZ1,LELT,LDIMT)
      
      COMMON /VPTSOL/  
c     Can be used for post-processing runs (SIZE .gt. 10+3*LDIMT flds)
     $                 VXLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VYLAG  (LX1,LY1,LZ1,LELV,2)
     $               , VZLAG  (LX1,LY1,LZ1,LELV,2)
     $               , TLAG   (LX1,LY1,LZ1,LELT,LORDER-1,LDIMT)
     $               , VGRADT1(LX1,LY1,LZ1,LELT,LDIMT)
     $               , VGRADT2(LX1,LY1,LZ1,LELT,LDIMT)
     $               , ABX1   (LX1,LY1,LZ1,LELV)
     $               , ABY1   (LX1,LY1,LZ1,LELV)
     $               , ABZ1   (LX1,LY1,LZ1,LELV)
     $               , ABX2   (LX1,LY1,LZ1,LELV)
     $               , ABY2   (LX1,LY1,LZ1,LELV)
     $               , ABZ2   (LX1,LY1,LZ1,LELV)
     $               , VDIFF_E(LX1,LY1,LZ1,LELT)
c     Solution data
     $               , VX     (LX1,LY1,LZ1,LELV)
     $               , VY     (LX1,LY1,LZ1,LELV)
     $               , VZ     (LX1,LY1,LZ1,LELV)
     $               , T      (LX1,LY1,LZ1,LELT,LDIMT)
     $               , VTRANS (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , VDIFF  (LX1,LY1,LZ1,LELT,LDIMT1)
     $               , BFX    (LX1,LY1,LZ1,LELV)
     $               , BFY    (LX1,LY1,LZ1,LELV)
     $               , BFZ    (LX1,LY1,LZ1,LELV)
     $               , cflf   (lx1,ly1,lz1,lelv)
     $               , c_vx   (lxd*lyd*lzd*lelv*ldim,lorder+1) ! charact
c     Solution data for magnetic field
     $               , BX     (LBX1,LBY1,LBZ1,LBELV)
     $               , BY     (LBX1,LBY1,LBZ1,LBELV)
     $               , BZ     (LBX1,LBY1,LBZ1,LBELV)
     $               , PM     (LBX2,LBY2,LBZ2,LBELV)
     $               , BMX    (LBX1,LBY1,LBZ1,LBELV)  ! Magnetic field R
     $               , BMY    (LBX1,LBY1,LBZ1,LBELV)
     $               , BMZ    (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX1   (LBX1,LBY1,LBZ1,LBELV) ! Extrapolation ter
     $               , BBY1   (LBX1,LBY1,LBZ1,LBELV) ! magnetic field rh
     $               , BBZ1   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBX2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBY2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BBZ2   (LBX1,LBY1,LBZ1,LBELV)
     $               , BXLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BYLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , BZLAG  (LBX1*LBY1*LBZ1*LBELV,LORDER-1)
     $               , PMLAG  (LBX2*LBY2*LBZ2*LBELV,LORDER2)
      
      common /expvis/  nu_star
      real             nu_star
      
      COMMON /CBM2/  
     $                 PR     (LX2,LY2,LZ2,LELV)
     $               , PRLAG  (LX2,LY2,LZ2,LELV,LORDER2)
c     
      COMMON /DIVERG/  QTL    (LX2,LY2,LZ2,LELT)
     $               , USRDIV (LX2,LY2,LZ2,LELT)
      
      COMMON /VPTMSK/  V1MASK (LX1,LY1,LZ1,LELV)
     $               , V2MASK (LX1,LY1,LZ1,LELV)
     $               , V3MASK (LX1,LY1,LZ1,LELV)
     $               , PMASK  (LX1,LY1,LZ1,LELV)
     $               , TMASK  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , OMASK  (LX1,LY1,LZ1,LELT)
     $               , VMULT  (LX1,LY1,LZ1,LELV)
     $               , TMULT  (LX1,LY1,LZ1,LELT,LDIMT)
     $               , B1MASK (LBX1,LBY1,LBZ1,LBELV)  ! masks for mag. f
     $               , B2MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , B3MASK (LBX1,LBY1,LBZ1,LBELV)
     $               , BPMASK (LBX1,LBY1,LBZ1,LBELV)  ! magnetic pressur
C     
C     Solution and data for perturbation fields
C     
      COMMON /PVPTSL/ VXP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VYP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VZP    (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , PRP    (LPX2*LPY2*LPZ2*LPELV,lpert)
     $              , TP     (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BQP    (LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              , BFXP   (LPX1*LPY1*LPZ1*LPELV,lpert)  ! perturbatio
     $              , BFYP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , BFZP   (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , VXLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VYLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , VZLAGP (LPX1*LPY1*LPZ1*LPELV,LORDER-1,lpert)
     $              , PRLAGP (LPX2*LPY2*LPZ2*LPELV,LORDER2,lpert)
     $              , TLAGP  (LPX1*LPY1*LPZ1*LPELT,LDIMT,LORDER-1,lpert)
     $              , EXX1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! Extrapolatio
     $              , EXY1P  (LPX1*LPY1*LPZ1*LPELV,lpert) ! perturbation
     $              , EXZ1P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXX2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXY2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              , EXZ2P  (LPX1*LPY1*LPZ1*LPELV,lpert)
     $              ,VGRADT1P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
     $              ,VGRADT2P(LPX1*LPY1*LPZ1*LPELT,LDIMT,lpert)
c     
      common /ppointr/ jp
# 4008 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4008 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 4009 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4009 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/CTIMER" 1
C     
# 2
      COMMON /CTIMER/ tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      COMMON /CTIME2/ tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      REAL*8          tmxmf,tmxms,tdsum,taxhm,tcopy,tinvc,tinv3
      REAL*8          tsolv,tgsum,tdsnd,tdadd,tcdtp,tmltd,tprep
     $               ,tpres,thmhz,tgop ,tgop1,tdott,tbsol,tbso2
     $               ,tsett,tslvb,tusbc,tddsl,tcrsl,tdsmx,tdsmn
     $               ,tgsmn,tgsmx,teslv,tbbbb,tcccc,tdddd,teeee
     $               ,tvdss,tschw,tadvc,tspro,tgop_sync,tsyc
     $               ,twal
C     
      COMMON /ITIMER/ nmxmf,nmxms,ndsum,naxhm,ncopy,ninvc,ninv3
      COMMON /ITIME2/ nsolv,ngsum,ndsnd,ndadd,ncdtp,nmltd,nprep
     $               ,npres,nhmhz,ngop ,ngop1,ndott,nbsol,nbso2
     $               ,nsett,nslvb,nusbc,nddsl,ncrsl,ndsmx,ndsmn
     $               ,ngsmn,ngsmx,neslv,nbbbb,ncccc,ndddd,neeee
     $               ,nvdss,nadvc,nspro,ngop_sync,nsyc,nwal
C     
      COMMON /PTIMER/ pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
     $               ,psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8          pmxmf,pmxms,pdsum,paxhm,pcopy,pinvc,pinv3
      REAL*8          psolv,pgsum,pdsnd,pdadd,pcdtp,pmltd,pprep
     $               ,ppres,phmhz,pgop ,pgop1,pdott,pbsol,pbso2
     $               ,psett,pslvb,pusbc,pddsl,pcrsl,pdsmx,pdsmn
     $               ,pgsmn,pgsmx,peslv,pbbbb,pcccc,pdddd,peeee
     $               ,pvdss,pspro,pgop_sync,psyc,pwal
C     
      REAL*8 etime1,etime2,etime0,gtime1,tscrtch
      REAL*8 dnekclock,dnekclock_sync
C     
      COMMON /CTIME3/ etimes,ttotal,tttstp,etims0,ttime
      real*8          etimes,ttotal,tttstp,etims0,ttime
C     
      integer icalld
      save    icalld
      data    icalld /0/
      
      common /ctimel/ ifsync
      logical         ifsync
# 4010 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4010 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 4011 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f" 2
# 4011 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/hsmg.f"
      
      
      real z(lx1*ly1*lz1*lelv)
      real rhs(lx1*ly1*lz1*lelv)
      
      common /scrhi/ h2inv (lx1,ly1,lz1,lelv)
      common /scrvh/ h1    (lx1,ly1,lz1,lelv),
     $               h2    (lx1,ly1,lz1,lelv)
      parameter (lt=lx1*ly1*lz1*lelt)
      common /SCRMG2/ r(lt),w(lt)
      common /SCRMG3/ e(2*lt)
      
      integer p_msk,p_b
      logical if_hybrid
      
      integer n1
      
c     if_hybrid = .true.    ! Control this from gmres, according
c     if_hybrid = .false.   ! to convergence efficiency
      
!$ACC  DATA PRESENT(r,w,z,e,rhs)
!$ACC&      PRESENT(mg_imask,mg_fast_s,mg_fast_d)
!$ACC&      PRESENT(mg_schwarz_wt,mg_rstr_wt,mg_jh)
      
      nel   = nelfld(ifield)
      
      op    =  1.                                     ! Coefficients for
      om    = -1.
      sigma =  1.
      if (if_hybrid) sigma = 2./3.
      
      l     = mg_h1_lmax
      n     = mg_h1_n(l,mg_fld)
      is    = 1                                       ! solve index
      
      call h1mg_schwarz_acc(z,rhs,sigma,l)            ! z := sigma W M  
                                                      !               Sc
      call copy_acc(r,rhs,n)                          ! r  := rhs
      
      if (if_hybrid) call h1mg_axm(r,z,op,om,l,w)     ! r  := rhs - A z
                                                      !  l
      
      do l = mg_h1_lmax-1,2,-1                        ! DOWNWARD Leg of 
         is = is + n
         n  = mg_h1_n(l,mg_fld)
                                                      !          T
         call h1mg_rstr_acc(r,l,.true.)               ! r   :=  J r
                                                      !  l         l+1
!        OVERLAPPING Schwarz exchange and solve:
      
         call h1mg_schwarz_acc(e(is),r,sigma,l)       ! e := sigma W M  
                                                      !  l            Sc
         if(if_hybrid)call h1mg_axm(r,e(is),op,om,l,w)! r  := r - A e
                                                      !  l           l
      enddo
      is = is+n
      
      call h1mg_rstr_acc(r,1,.false.)                 ! r  :=  J  r
                                                      !  l         l+1
      p_msk = p_mg_msk(l,mg_fld)
      
      call h1mg_mask_acc(r,mg_imask(p_msk),nel)       !        -1
      
      n1 = mg_h1_n(1,mg_fld)
      
!$ACC UPDATE HOST(r(1:n1))
      call hsmg_coarse_solve ( e(is) , r )        ! e  := A   r
!$ACC UPDATE DEVICE(e(is:is+n1))
      call h1mg_mask_acc(e(is),mg_imask(p_msk),nel)   !  1     1   1
      
c     nx = mg_nh(1)
c     call outnxfld (e(is),nx,nelv,'ecrsb4',is)
c     call h1mg_mask(e(is),mg_imask(p_msk),nel)       !  1     1   1
c     call outnxfld (e(is),nx,nelv,'ecrsaf',is)
c     call exitt
      
      do l = 2,mg_h1_lmax-1                           ! UNWIND.  No smoo
         im = is
         is = is - n
         n  = mg_h1_n(l,mg_fld)
         call hsmg_intp_acc (w,e(im),l-1)             ! w   :=  J e
         i1=is-1                                      !            l-1
      
!$ACC PARALLEL LOOP
         do i=1,n
            e(i1+i) = e(i1+i) + w(i)                  ! e   :=  e  + w
         enddo                                        !  l       l
      enddo
      
      l  = mg_h1_lmax
      n  = mg_h1_n(l,mg_fld)
      im = is  ! solve index
      
      call hsmg_intp_acc(w,e(im),l-1)                 ! w   :=  J e
      
!$ACC PARALLEL LOOP
      do i = 1,n                                      !            l-1
         z(i) = z(i) + w(i)                           ! z := z + w
      enddo
      
      call dsavg_acc(z) ! Emergency hack --- to ensure continuous z!
      
!$ACC END DATA
      
      return
      end
      
      

