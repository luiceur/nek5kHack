# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f"
c-----------------------------------------------------------------------
      subroutine gfdm_pres_solv(z,r,ug,wg,kwave2) ! (A - kwave2*B)z = r
      

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/pipe_2013_11_27/SIZE" 1
C     Dimension file to be included     
C     
C     HCUBE array dimensions
C     
# 5
      parameter (ldim=3)
      parameter (lx1=10,ly1=lx1,lz1=lx1,lelt=410,lelv=lelt)
      parameter (lxd=10,lyd=lxd,lzd=lxd)
      parameter (lelx=1,lely=1,lelz=1)
      
      parameter (lzl=3 + 2*(ldim-3))
      
c      parameter (lx2=lx1-2)
c      parameter (ly2=ly1-2)
c      parameter (lz2=lz1-2)
      parameter (lx2=lx1)
      parameter (ly2=ly1)
      parameter (lz2=lz1)
      
      parameter (lx3=lx1)
      parameter (ly3=ly1)
      parameter (lz3=lz1)
      
      parameter (lp = 4)
      parameter (lelg = 410)
c     
c     parameter (lpelv=lelv,lpelt=lelt,lpert=3)  ! perturbation
c     parameter (lpx1=lx1,lpy1=ly1,lpz1=lz1)     ! array sizes
c     parameter (lpx2=lx2,lpy2=ly2,lpz2=lz2)
c     
      parameter (lpelv=1,lpelt=1,lpert=1)        ! perturbation
      parameter (lpx1=1,lpy1=1,lpz1=1)           ! array sizes
      parameter (lpx2=1,lpy2=1,lpz2=1)
c     
c     parameter (lbelv=lelv,lbelt=lelt)          ! MHD
c     parameter (lbx1=lx1,lby1=ly1,lbz1=lz1)     ! array sizes
c     parameter (lbx2=lx2,lby2=ly2,lbz2=lz2)
c     
      parameter (lbelv=1,lbelt=1)                ! MHD
      parameter (lbx1=1,lby1=1,lbz1=1)           ! array sizes
      parameter (lbx2=1,lby2=1,lbz2=1)
      
C     LX1M=LX1 when there are moving meshes; =1 otherwise
      parameter (lx1m=1,ly1m=1,lz1m=1)
      parameter (ldimt= 2)                       ! 3 passive scalars + T
      parameter (ldimt1=ldimt+1)
      parameter (ldimt3=ldimt+3)
c     
c     Note:  In the new code, LELGEC should be about sqrt(LELG)
c     
      PARAMETER (LELGEC = 1)
      PARAMETER (LXYZ2  = 1)
      PARAMETER (LXZ21  = 1)
      
      PARAMETER (LMAXV=LX1*LY1*LZ1*LELV)
      PARAMETER (LMAXT=LX1*LY1*LZ1*LELT)
      PARAMETER (LMAXP=LX2*LY2*LZ2*LELV)
      PARAMETER (LXZ=LX1*LZ1)
      PARAMETER (LORDER=3)
      PARAMETER (MAXOBJ=4,MAXMBR=LELT*6)
      PARAMETER (lhis=100)         ! # of pts a proc reads from hpts.in
                                   ! Note: lhis*np > npoints in hpts.in
C     
C     Common Block Dimensions
C     
      PARAMETER (LCTMP0 =2*LX1*LY1*LZ1*LELT)
      PARAMETER (LCTMP1 =4*LX1*LY1*LZ1*LELT)
C     
C     The parameter LVEC controls whether an additional 42 field arrays
C     are required for Steady State Solutions.  If you are not using
C     Steady State, it is recommended that LVEC=1.
C     
      PARAMETER (LVEC=1)
C     
C     Uzawa projection array dimensions
C     
      parameter (mxprev = 20)
      parameter (lgmres = 30)
C     
C     Split projection array dimensions
C     
      parameter(lmvec = 1)
      parameter(lsvec = 1)
      parameter(lstore=lmvec*lsvec)
c     
c     NONCONFORMING STUFF
c     
      parameter (maxmor = lelt)
C     
C     Array dimensions
C     
      COMMON/DIMN/NELV,NELT,NX1,NY1,NZ1,NX2,NY2,NZ2
     $,NX3,NY3,NZ3,NDIM,NFIELD,NPERT,NID
     $,NXD,NYD,NZD
      
c automatically added by makenek
      parameter(lxo   = lx1) ! max output grid size (lxo>=lx1)
      
c automatically added by makenek
      parameter(lpart = 1  ) ! max number of particles
      
c automatically added by makenek
      integer ax1,ay1,az1,ax2,ay2,az2
      parameter (ax1=lx1,ay1=ly1,az1=lz1,ax2=lx2,ay2=ly2,az2=lz2) ! runn
      
c automatically added by makenek
      parameter (lxs=1,lys=lxs,lzs=(lxs-1)*(ldim-2)+1) !New Pressure Pre
      
c automatically added by makenek
      parameter (lfdm=0)  ! == 1 for fast diagonalization method
# 5 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f" 2
# 5 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/INPUT" 1
C     
C     Input parameters from preprocessors.
C     
C     Note that in parallel implementations, we distinguish between
C     distributed data (LELT) and uniformly distributed data.
C     
C     Input common block structure:
C     
C     INPUT1:  REAL            INPUT5: REAL      with LELT entries
C     INPUT2:  INTEGER         INPUT6: INTEGER   with LELT entries
C     INPUT3:  LOGICAL         INPUT7: LOGICAL   with LELT entries
C     INPUT4:  CHARACTER       INPUT8: CHARACTER with LELT entries
C     
# 14
      COMMON /INPUT1/ PARAM(200)
     $               ,RSTIM,VNEKTON
     $               ,CPFLD(LDIMT1,3)
     $               ,CPGRP(-5:10,LDIMT1,3)
     $               ,QINTEG(LDIMT3,MAXOBJ)
C     
      COMMON /INPUT2/ MATYPE(-5:10,LDIMT1)
     $               ,NKTONV,NHIS,LOCHIS(4,lhis)
     $               ,IPSCAL,NPSCAL,IPSCO, ifldmhd
     $               ,IRSTV,IRSTT,IRSTIM,NMEMBER(MAXOBJ),NOBJ
     $               ,NGEOM
C     
      COMMON /INPUT3/ IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC(LDIMT1),IFTMSH(0:LDIMT1)
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL(LDIMT1)
     $               ,IFVARP(LDIMT1),IFPSCO(LDIMT1),IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO(LDIMT1),IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFSCHCLOB,IFUSERVP,
     $               IFCYCLIC,IFMOAB,IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,
     $               IFXYO_,ifaziv,IFNEKNEK
      LOGICAL         IF3D
     $               ,IFFLOW,IFHEAT,IFTRAN,IFAXIS,IFSTRS,IFSPLIT
     $               ,IFMGRID,IFADVC,IFTMSH
     $               ,IFMVBD,IFNATC,IFCHAR,IFNONL
     $               ,IFVARP,IFPSCO,IFVPS
     $               ,IFMODEL,IFKEPS
     $               ,IFINTQ,IFCONS
     $               ,IFXYO,IFPO,IFVO,IFTO,IFTGO,IFPSO,IFFMTIN
     $               ,IFBO
     $               ,IFANLS,IFANL2,IFMHD,IFESSR,IFPERT,IFBASE
     $               ,IFCVODE,IFLOMACH,IFEXPLVIS,IFUSERVP,IFCYCLIC
     $               ,IFSCHCLOB
     $               ,IFMOAB, IFCOUP, IFVCOUP, IFUSERMV,IFREGUO,IFXYO_
     $               ,ifaziv,IFNEKNEK
      LOGICAL         IFNAV
      EQUIVALENCE    (IFNAV, IFADVC(1))
C     
      COMMON /INPUT4/ HCODE(11,lhis),OCODE(8),RSTV,RSTT,DRIVC(5)
     $               ,INITC(15),TEXTSW(100,2)
      CHARACTER*1     HCODE
      CHARACTER*2     OCODE
      CHARACTER*10    DRIVC
      CHARACTER*14    RSTV,RSTT
      CHARACTER*40    TEXTSW,TURBMOD
      CHARACTER*132    INITC
      EQUIVALENCE    (TURBMOD,TEXTSW(1,1))
C     
      COMMON /CFILES/ REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      CHARACTER*132   REAFLE,FLDFLE,DMPFLE,HISFLE,SCHFLE,OREFLE,NREFLE
      COMMON /CFILE2/ SESSION,PATH,RE2FLE, H5MFLE
      CHARACTER*132   SESSION,PATH,RE2FLE,H5MFLE
C     
C proportional to LELT
C     
      COMMON /INPUT5/ XC(8,LELT),YC(8,LELT),ZC(8,LELT)
     $               ,BC(5,6,LELT,0:LDIMT1)
     $               ,CURVE(6,12,LELT)
     $               ,CERROR(LELT)
C     
      COMMON /INPUT6/ IGROUP(LELT),OBJECT(MAXOBJ,MAXMBR,2)
      INTEGER OBJECT
C     
      COMMON /INPUT8/ CBC(6,LELT,0:LDIMT1),CCURVE(12,LELT)
     $              , CDOF(6,LELT), solver_type
      CHARACTER*1     CCURVE,CDOF
      CHARACTER*3     CBC, solver_type
      COMMON /INPUT9/ IEACT(LELT),NEACT
C     
C material set ids, BC set ids, materials (f=fluid, s=solid), bc types
      PARAMETER (NUMSTS=50)
      COMMON /INPUTMI/ NUMFLU, NUMOTH, NUMBCS 
     $	             , MATINDX(NUMSTS),MATIDS(NUMSTS),IMATIE(LELT)
     $ 	             , IBCSTS (NUMSTS) 
      COMMON /INPUTMR/ BCF    (NUMSTS)
      COMMON /INPUTMC/ BCTYPS (NUMSTS)
      CHARACTER*3 BCTYPS
      integer     bcf
      
# 6 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f" 2
# 6 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/PARALLEL" 1
C     
C     Communication information
C     NOTE: NID is stored in 'SIZE' for greater accessibility
# 4
      COMMON /CUBE1/ NODE,PID,NP,NULLPID,NODE0
      INTEGER        NODE,PID,NP,NULLPID,NODE0
      
C     
C     Maximum number of elements (limited to 2**31/12, at least for now)
      PARAMETER(NELGT_MAX = 178956970)
C     
      COMMON /HCGLB/ NVTOT,NELG(0:LDIMT1)
     $              ,LGLEL(LELT)
     $              ,GLLEL(LELG)
     $              ,GLLNID(LELG)
     $              ,NELGV,NELGT
      
      INTEGER        GLLEL,GLLNID,LGLEL
      INTEGER*8      NVTOT
C     
      COMMON /DIAGL/  IFGPRNT
      LOGICAL IFGPRNT
      COMMON/PRECSN/ WDSIZE,ISIZE,LSIZE,CSIZE
      COMMON/PRECSL/ IFDBLAS
      INTEGER WDSIZE,ISIZE,LSIZE,CSIZE
      LOGICAL IFDBLAS
C     
C     crystal-router, gather-scatter, and xxt handles (xxt=csr grid solv
C     
      common /comm_handles/ cr_h, gsh, gsh_fld(0:ldimt3), xxth(ldimt3)
      integer               cr_h, gsh, gsh_fld          , xxth
# 7 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f" 2
# 7 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/TSTEP" 1
# 1
      COMMON /TSTEP1/ TIME,TIMEF,FINTIM,TIMEIO
     $               ,DT,DTLAG(10),DTINIT,DTINVM,COURNO,CTARG
     $               ,AB(10),BD(10),ABMSH(10)
     $               ,AVDIFF(LDIMT1),AVTRAN(LDIMT1),VOLFLD(0:LDIMT1)
     $               ,TOLREL,TOLABS,TOLHDF,TOLPDF,TOLEV,TOLNL,PRELAX
     $               ,TOLPS,TOLHS,TOLHR,TOLHV,TOLHT(LDIMT1),TOLHE
     $               ,VNRMH1,VNRMSM,VNRML2,VNRML8,VMEAN
     $               ,TNRMH1(LDIMT),TNRMSM(LDIMT),TNRML2(LDIMT)
     $               ,TNRML8(LDIMT),TMEAN(LDIMT)
C     
      COMMON /ISTEP2/ IFIELD,IMESH,ISTEP,NSTEPS,IOSTEP,LASTEP,IOCOMM
     $               ,INSTEP
     $               ,NAB,NBD,NBDINP,NTAUBD 
     $               ,NMXH,NMXP,NMXE,NMXNL,NINTER
     $               ,NELFLD(0:LDIMT1)
     $               ,nconv,nconv_max
C     
      COMMON /TSTEP3/ PI,BETAG,GTHETA
      COMMON /TSTEP4/ IFPRNT,if_full_pres
      LOGICAL IFPRNT,if_full_pres
c     
      COMMON /TSTEP5/ lyap(3,lpert)  !  lyapunov simulation history
      real lyap
# 8 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f" 2
# 8 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f"

# 1 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/ZPER" 1
      
c     Eigenvalue arrays and pointers for Global Tensor Product 
c     parameter (lelg_sm=2)
c     parameter (ltfdm2 =2)
c     parameter (lelg_sm=lelg)
c     parameter (ltfdm2=2*lx2*ly2*lz2*lelt)
c     parameter (leig2=2*lx2*lx2*(lelx*lelx+lely*lely+lelz*lelz))
c     parameter (leig =2*lx2*(lelx+lely+lelz))
      
# 10
      parameter (lfdm0 = 1-lfdm)
      parameter (lelg_sm=lfdm0+lfdm*lelg)
      parameter (ltfdm2 =lfdm0+lfdm*2*lx2*ly2*lz2*lelt)
      parameter (leig2  =lfdm0+lfdm*2*lx2*lx2
     $                             *(lelx*lelx+lely*lely+lelz*lelz))
      parameter (leig   =lfdm0+lfdm*2*lx2*(lelx+lely+lelz))
      
      
      common /peigi/ neigx ,neigy ,neigz
     $             , pvalx ,pvaly ,pvalz 
     $             , pvecx ,pvecy ,pvecz 
      integer        pvalx ,pvaly ,pvalz 
     $             , pvecx ,pvecy ,pvecz 
      
      common /eigpr/ sp(leig2),spt(leig2),eigp(leig)
     $              ,wavep(ltfdm2)
      common /eigpi/ msp(3,2),mlp(3,2)
      
      
c     Logical, array and geometry data for tensor-product box
      common /perlog/  ifycrv,ifzper,ifgfdm,ifgtp,ifemat
      logical          ifycrv,ifzper,ifgfdm,ifgtp,ifemat
      
      common /gfdmic/  nelx,nely,nelz,nelxy
     $                ,lex2pst(3),pst2lex(3)
     $                ,ngfdm_p(3),ngfdm_v(3,2)
      integer          lex2pst   ,pst2lex
      
c     Complete exchange arrays for pressure
c     common /gfdmcx/  part_in(0:lp),part_out(0:lp)
      parameter (lp_small=256)
      common /gfdmcx/  part_in(0:lp_small),part_out(0:lp_small)
     $                ,msg_id(0:lp_small,2)
     $                ,mcex
      integer          part_in,part_out
      
c     Permutation arrays for gfdm pressure solve
      common /gfdmia/  tpn1(ltfdm2),tpn2(ltfdm2)
     $                ,tpn3(ltfdm2),ind23(ltfdm2)
      integer tpn1,tpn2,tpn3
      
      parameter (lfdx =lfdm0+lfdm*lx2*lelx)
      parameter (lfdy =lfdm0+lfdm*ly2*lely)
      parameter (lfdz =lfdm0+lfdm*lz2*lelz)
      common /pergeo/  xgtp(0:lelx),ygtp(0:lely),zgtp(0:lelz)
     $                ,xmlt(lfdx),ymlt(lfdy),zmlt(lfdz)
      
      
c     Metrics for 2D x tensor-product solver
      common /permet/  rx2  (lx2,ly2,lelv)
     $               , ry2  (lx2,ly2,lelv)
     $               , sx2  (lx2,ly2,lelv)
     $               , sy2  (lx2,ly2,lelv)
     $               , w2d  (lx2,ly2,lelv)
     $               , bxyi (lx1,ly1,lelv)
      
      common /gtpcbc/  gtp_cbc(6,0:ldimt1+1)
      character*3      gtp_cbc
# 9 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f" 2
# 9 "/lustre/atlas/scratch/csep22/trn001/nek5_acc/nek_2013_11_27/gfdm_solve.f"
      
      real z (lx2*ly2*lz2*lelv),r (lx2*ly2*lz2*lelv)
      real ug(lx2*ly2*lz2*lelv),wg(lx2*ly2*lz2*lelv)
      real kwave2
      
      mfld = 1
      if (ifmhd.and.ifield.gt.1) mfld = 2
      
c     Set up diagonal for solver
      
      ii= 1          ! we'll need to change this for multiple flds
      l = ngfdm_p(1)
      m = ngfdm_p(2)
      n = ngfdm_p(3)
      i = mlp(1,mfld)
      j = mlp(2,mfld)
      k = mlp(3,mfld)
      call gfdm_set_diagp(wavep(ii),tpn1,mcex
     $         ,eigp(i),l,eigp(j),m,eigp(k),n,kwave2)
      
      mp   = ngfdm_p(pst2lex(1))
      ms   = ngfdm_p(pst2lex(2))
      mt   = ngfdm_p(pst2lex(3))
      
      msfp = msp(pst2lex(1),mfld)
      msfs = msp(pst2lex(2),mfld)
      msft = msp(pst2lex(3),mfld)
      
      ntot  = nx2*ny2*nz2*nelv
      
      m     = ntot/mp
      nwave = mcex
      mpt   = mcex/(ms*mt)
      
      dtbdi = 1   
      if (ifemat.and..not.ifmhd) dtbdi=bd(1)/dt ! scale by BDF coefficie
      
c     write(6,*) 'msfp:',msfp,msfs,msft,mp,ms,mt,sp(msfp)
c     call outmat(sp(msfp),mp,mp,'S  x  ',istep)
c     call outmat(sp(msfs),ms,ms,'S  y  ',ifield)
c     call outmat(sp(msft),mt,mt,'S  z  ',mt)
c     call outmat(wavep   ,mp,ms,'WAVE  ',mt)
c     stop
      
      if (if3d) then
         call copy    (ug,r,ntot)
         call swap_ip (ug,tpn2,ntot)
         call mxm     (ug,m,sp (msfp),mp,wg,mp)
         call cexr    (ug,wg,m,mp,part_out,part_in,msg_id,wdsize,nid,np)
         call swap_ip (ug,ind23,mcex)
         call mxm     (spt(msfs),ms,ug,ms,wg,mpt*mt)
         call mxm     (wg,ms*mpt,sp (msft),mt,ug,mt)
         call col2s2  (ug,wavep,dtbdi,mcex)
         call mxm     (ug,ms*mpt,spt(msft) ,mt,wg,mt)
         call mxm     (sp (msfs),ms,wg,ms,ug,mpt*mt)
         call swapt_ip(ug,ind23,mcex)
         call cextr   (wg,m,mp,ug,part_out,part_in,msg_id,wdsize,nid,np)
         call mxm     (wg,m,spt(msfp),mp,z,mp)
         call swapt_ip(z,tpn2,ntot)
      else
         call copy    (ug,r,ntot)
         call swap_ip (ug,tpn2,ntot)
         call mxm     (ug,m,sp (msfp),mp,wg,mp)
         call cexr    (ug,wg,m,mp,part_out,part_in,msg_id,wdsize,nid,np)
         call swap_ip (ug,ind23,mcex)
         call mxm     (spt(msfs),ms,ug,ms,wg,mpt)
         call col2s2  (wg,wavep,dtbdi,mcex)
         call mxm     (sp (msfs),ms,wg,ms,ug,mpt)
         call swapt_ip(ug,ind23,mcex)
         call cextr   (wg,m,mp,ug,part_out,part_in,msg_id,wdsize,nid,np)
         call mxm     (wg,m,spt(msfp),mp,z,mp)
         call swapt_ip(z,tpn2,ntot)
      endif
      
      return
      end
c-----------------------------------------------------------------------
